[["index.html", "R Markdown 指南 前言", " R Markdown 指南 王祎帆 闫求识 高春辉 2021-07-06 前言 "],["know-rmarkdown.html", "第 1 章 认识 R Markdown 1.1 数据分析报告和文档 1.2 个人简历 1.3 网站 1.4 幻灯片 1.5 交互报表 1.6 R Markdown 的渊源与历史", " 第 1 章 认识 R Markdown 本章从 R Markdown 的应用开始，遴选了不同场合 R Markdown 的用例和解决的问题。最后回顾了 R Markdown 渊源的历史发展。话不多说，我们在以下各小节中快速浏览一些 R Markdown 文档的用例，它们有些直接基于原生的 R Markdown 包，有些来自 R Markdown 的扩展包。越来越多的扩展为 R Markdown 文档增加了新的输出格式，为生态体系提供了更丰富的功能覆盖。读者可以挑选自己最感兴趣的使用场合深入后面对应章节的阅读，也可以在 Github 上以 R Markdown 为关键词探索各式各样的输出格式。 1.1 数据分析报告和文档 从诞生开始，R 便是一门致力于交互式数据分析的语言，R 的用户便时常有着制作数据分析报告的需求，这也是 R Markdown 最常见和基础的功能。它支持 HTML, PDF, Word, EPUB 等多种输出格式以及与之配套开箱即用的主题系统。用户可以将创作重心放在内容上，写作完成后一键输出不同格式，让 R Markdown 的自动化的编译机制代劳形式上的调整。例如，以下 HTML，PDF 和 Word 三种格式的文档是用同一个 R Markdown 生成的。 除了多样的输出格式外，R Markdown 驱动的数据分析报告还解决了很多数据分析报告写作中的痛点： 之前在使用 R 或者其他数据分析工具时，经常需要在 Word 里写结论，在脚本里敲代码，在图表区生成图，将它们复制粘贴到一起后，还要操心格式问题，有没有什么自动化的方法？ 我的工作需要日常性的数据产出，如何创作一篇参数化、可复用的文档模板，从此可以在更新数据的同时同步结论和图表？ 如何确保分析过程和结论是可重复的，别人是否能利用同样的数据得到我的结论？ 我不了解网页开发，如何在报告中插入可交互的图表和网页元素？ 同时，R Markdown 还为 R 语言之外的几十种编程语言提供了一定程度的支持，例如 Python，C++，Julia，Bash，SQL 等，这意味着我们可以在一篇报告中混用多个工具。Python 作为数据分析师的另一大利器，在 reticulate 包 (Ushey, Allaire, and Tang 2020) 的帮助下可以流畅地与 R 代码在 R Markdown 文档中并用。下面的例子中，我们先用 R 导入数据并作数据预处理，随后将 R 中的数据传递框到 Python 环境中，生成 pandas 格式的 DataFrame, 并用 seaborn 包作可视化。 # R 部分: 导入和预处理美国各州犯罪数据 arrests &lt;- datasets::USArrests arrests$State &lt;- rownames(arrests) # Python 部分，导入 R 数据，提取谋杀率最高的 10 个州，并用 seaborn 包作柱形 import pandas as pd import seaborn as sns top_states = r.arrests\\ .sort_values([&quot;Murder&quot;], ascending = False)\\ .head(10) sns.barplot(x = &quot;Murder&quot;, y = &quot;State&quot;, data = top_states) 当读者需要创作更大篇幅的文档甚至书籍时，我们可能不希望仅使用一篇 R Markdown 文档组织全部内容。bookdown 包 (Xie 2020) 的可以让用户将内容分散到多个 R Markdown 文档中，在编译时合成各文档便提供更适于书籍和在线文档的输出格式。此外，bookdown 对 R Markdown 的扩展还包括支持交叉引用，定理公式环境，文献引用等。bookdown 的输出结果非常适合用于制作在线教材与讲义，例如北京大学李东风老师的《R 语言教程》，本书的在线版本也是用 bookdown 生成的。bookdown.org 列出了更多 bookdown 制作的在线书籍。 图 1.1: 使用 bookdown 制作的中文图书范例, 一个章节对应一个 R Markdown 文档 在学术报告或论文的撰写中，用户可能对格式有更细致的要求。很多 R Markdown 的扩展包在基础输出格式之上进一步定制，做到了编译后即可直接投稿的程度。rticles 包提供了很多期刊和出版商的模板文档，例如 R Journals 和 Journals of Statistical Software。中文用户可能较常用 rticles 提供的 CTeX 输出格式，它让 R Markdown 输出的 PDF 可以正常显示中文字符。 1.2 个人简历 一些 R Markdown 扩展包提供了适用于个人简历和 CV 的输出格式。例如基于 pagedown 包的简历模板，和 vitae 下多种 CV 模板。 除了使用模板外， R Markdown 还能让你的简历变得更加“数据驱动”。datadrivencv 包把简历中的各项教育背景，工作经历和项目经验等视作电子表格中的一条记录，我们可以仅维护这张数据表，R Markdown 负责简历的格式。除此之外，还可以插入 R 代码生成的交互图表，让我们的简历动起来。图1.2是 datadrivencv 包的作者 Nick Strayer 结合 pagedown 包制作的个人简历。 图 1.2: Nick Strayer用 datadrivencv 和 pagedown 包制作的 CV 示意 1.3 网站 原生的 R Markdown 包内置了生成简单静态网站的功能。简单来说，我们在一个 yaml 文件通过键值对定义网站的标题，导航栏，页面结构等元数据，而后创建几个 R Markdown 文档在其中填充内容，内置的站点生成器将每个 R Markdown 文档渲染为一个 HTML 页面输出。 为满足创建更加复杂且精美的网站的需求，blogdown 包使用了第三方的开源静态网站生成器：Hugo。Hugo 是目前最快，最受欢迎的静态网站生成器之一，一般用户通常需要用命令行的方式与之交互。作为幸福的 R 用户，我们可以在 R Markdown 文档中写作，随后调用 blogdown 中封装好的函数操作 Hugo 的编译功能，最后生成网站。 图 1.3: Hugo 社区贡献了在 blogdown 中大量简单易用的网站模板 包如其名，对个人用户来说，blogdown 特别适合制作博客类的个人网站。例如，求职时可以用博客日志的方式展示自己的项目，存放电子简历和 CV，归档各类学习心得等。Hugo 的主题列表 列出了一些可选的网站模板，其中大部分均可以在 blogdown 中一键生成。最后，我们给出几个不同主题的 blogdown 网站的样例 Rob J Hyndman 的个人网站 Alison Hill 的个人网站 《现代统计图形》的图书主页 1.4 幻灯片 R Markdown 和扩展包支持输出多种常见的幻灯片格式，例如 PowerPoint，Beamer，isoslides 和 Slidy 等。除此之外，我们特别推荐读者关注 xaringan 包，它基于 JavaScript 中的 remark.js 库设计了灵活的输出方案。默认的模板，了解 css 和一定 JavaScript 的读者还可以在此基础上设计出炫酷的演示文档。xaringanExtra 包在此基础上提供了更多有趣的增强插件。 图 1.4: xaringan 提供的幻灯片模板示意 1.5 交互报表 报表是一种常见的商业报告形式，用 R Markdown 做报表不仅能将分析与结论天然结合地在一起，还能利用 R 强大的图表功能。flexdashboard 包基于 HTML 格式提供了这类报表的模板，还内置了一些 HTML 组件作为常见报表元素， 例如指标盒，增长仪表，导航栏等。 1.6 R Markdown 的渊源与历史 本章回顾了 R Markdown 在技术和工具层面的渊源和它的发展历史。喜欢直接进入实操的读者可以跳过本节，从 第 2 章开始。如果读者已经掌握了 R Markdown 的基础知识，书写过一些 R Markdown 的文档, 也可以直接开始阅读第 4 章。 "],["installation.html", "第 2 章 安装 2.1 安装 R Markdown 2.2 创建第一个 R Markdown 文档 2.3 安装 Tinytex", " 第 2 章 安装 本章介绍安装 R Markdown 相关依赖包的方法，并编译第一个 R Markdown 源文档，输出为 HTML 和 PDF 两种格式。 读者学习 R Markdown 的过程中，可能会用到许多文件记录学习过程，例如 R Markdown 自己的文档，R 的代码脚本，图片和其他笔记文件等等。我们推荐使用 RStudio 自带的项目功能管理相关的文件。可以通过菜单栏中的 File --&gt; New Project 创建新项目，此时 RStudio 会在选定的根目录下生成一个后缀为 .Rproj 的文件，我们可以在该目录创建不同的文件夹记录学习过程。下次启动项目时，只需要通过 RStudio 编辑器右上角下拉菜单内的 Open Project 选项加载该 .Rproj 文件，或者直接双击该文件并使用 RStudio 打开。一个使用项目文件的好处是，我们可以在一个固定的根目录内使用相对路径引用各种文件资源。例如，我们可能有下面的文件结构 ch1 - first-rmd.Rmd - second-rmd.Rmd ch2 - third-rmd.Rmd scripts - utils.R images - my-picture.png ... learn-rmarkdown.Rproj 此时，如果需要在 ch1 文件夹中的 first-rmd.Rmd 中引用 images 文件夹中的 my-picture.png ，可以使用相对路径 ../images/my-picture.png。无论后续我们在 images 中添加多少文件，都只需要在相对路径中改变图片的名称。 此外，使用项目文件还可以让 RStudio 自适应一些 R Markdown 包的特定选项，为我们后续介绍的诸多 R Markdown 扩展功能提供更好的编辑器支持。 2.1 安装 R Markdown 编译 R Markdown 文档需要安装 rmarkdown 包, 在 RStudio 的控制台中运行 install.packages(&quot;rmarkdown&quot;) 中国大陆的读者有可能遇到网络问题，这时可以在 RStudio 的 Tools --&gt; Global Options --&gt; Packages 将 Primary Cran Repository 更改为国内的镜像。也可以在 install.packages 中设置 repos 参数 install.packages(&quot;rmarkdown&quot;, repos = &lt;某镜像&gt;) 2.2 创建第一个 R Markdown 文档 安装完成后，我们可以开始创建第一个 R Markdown 文档。在 RStudio 中选择 File --&gt; New File --&gt; R Markdown, 弹出以下提示框 在这里可以提前设定输出文档的标题，作者和格式。这里我们保留默认设置，点击 OK 即可。 随后，RStudio 编辑器内生成了如下内容 --- title: &quot;Untitled&quot; output: html_document --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` ## R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: ```{r cars} summary(cars) ``` ## Including Plots You can also embed plots, for example: ```{r pressure, echo=FALSE} plot(pressure) ``` Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot. 在编辑器内保存该文件，我们可以发现根目录下增加了 first-rmd.Rmd 文件，这种后缀为 .Rmd 的文件即是 R Markdown 的源文档。在源文件中，我们定义了 R Markdown 输出文件的形式和内容。本书后续章节对文本和代码的编辑以及日常使用均是围绕类似这样的源文档展开的。 点击源文档顶部的 Knit 按钮，RStudio 首先提示应保存源文档，读者可以在不更改 .Rmd 文件后缀的情况下任意选择保存名称, 但最好不要包含中文。 保存后，R Markdown 包开始将源文档编译为输出。几秒后弹出以下界面说明编译成功，同时 R Markdown 包安装无误，可以开始快乐的写作了。 ## PhantomJS not found. You can install it with webshot::install_phantomjs(). If it is installed, please make sure the phantomjs executable can be found via the PATH variable. 图 2.1: first-rmd.Rmd 文件输出的 HTML 文档 图 2.1 给出了我们新创建的 first-rmd.Rmd 文件的 HTML 格式输出结果。此时，与该 R Markdown 源文件同级目录下也应该出现一个 first-rmd.html 文件，读者可以用浏览器打开该 HTML 验证是否与 RStudio 面板中输出的结果一致。 一些读者可能会疑惑，之前点击 Knit 时，为什么我们没有用 library(rmarkdown) 导入 rmarkdown 包，也没有在源文档中运行相关的函数，编译仍能成功呢？当我们点击 Knit 的时候，RStudio 自行调用了 # 第一个参数为你保存的文件名 rmarkdown::render(&quot;first-rmd.Rmd&quot;, output_format = &quot;html_document&quot;) 读者不妨自己在控制台内运行一遍以上代码，看结果与点击 Knit 是否相同。 2.3 安装 Tinytex 对于需要生成 PDF 文档的读者，还需要安装 tinytex 包 # 安装 tinytex 包 install.packages(&quot;tinytex&quot;) # 安装 TinyTex 套件 tinytex::install_tinytex() 安装完成后，在 RStudio 中打开之前保存的 R Markdown 源文档，将第三行 output_format: html_document 更改为 output_format: pdf_document。点击 Knit 后，生成如下两页 PDF 文档，说明安装成功 如果 TinyTeX 下载速度较慢或者下载失败，读者可以先在 Github 上下载对应的压缩包，然后用 install_prebuilt 安装该下载文件，例如 tinytex:::install_prebuilt(&#39;~/Downloads/TinyTeX-v2021.01.zip&#39;) 熟悉 LaTeX 的用户可能会好奇 TinyTeX 的工作机制。TinyTeX 是一个基于 TeX Live 的自定义轻量级 LaTeX 套件，特别为 R Markdown 用户设计了许多定制化的 PDF 编译功能。例如，它可以自动安装编译过程中缺少的宏包。大部分情况下，我们不需要直接使用 TinyTeX 包，R Markdown 已经与之高度集成。此外，建议在安装 TinyTeX 之前卸载系统中已有的 LaTeX 套件，例如 Tex Live，MiKTeX，Mac—TeX 等，否则可能产生冲突。更多信息请参照文档。 "],["rmarkdown-basics.html", "第 3 章 基础知识 3.1 再看 HTML 输出文件 3.2 Markdown 语法 3.3 使用 R 代码 3.4 输出格式 3.5 R Markdown 的编译过程", " 第 3 章 基础知识 本章介绍读者使用 R Markdown 写作的必要基础知识，包括使用 Markdown 语法为文本赋予格式，用代码段和行内代码两种方式在文档中嵌入 R 代码，如何在 R Markdown 中设置输出格式和它们的细节选项。最后，我们介绍了 R Markdown 的底层的编译机制，说明了 knitr, R Markdown, Pandoc, TinyTeX 等工具是如何协作编译出输出结果的。 3.1 再看 HTML 输出文件 在 @ref(#create-first-rmd) 节中，我们编译了 first-rmd.Rmd 源文档，生成了同名的 first-rmd.html HTML 文件，效果如图 2.1 所示。本节中，我们进入该 HTML 文件内部，进一步了解 R Markdown 的输出机制。 读者可以用任意文本编辑器打开first-rmd.html，略过一大段 script 脚本引用后，可以发现如下所示的代码片段，即为该 HTML 文件的文本主体。由于文件内代码较多，建议直接搜索 This is an R Markdown document 定位到相应片段。 &lt;div id=&quot;r-markdown&quot; class=&quot;section level2&quot;&gt; &lt;h2&gt;R Markdown&lt;/h2&gt; &lt;p&gt;This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;a href=&quot;http://rmarkdown.rstudio.com&quot; class=&quot;uri&quot;&gt;http://rmarkdown.rstudio.com&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;When you click the &lt;strong&gt;Knit&lt;/strong&gt; button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:&lt;/p&gt; &lt;pre class=&quot;r&quot;&gt;&lt;code&gt;summary(cars)&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code&gt; ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;div id=&quot;including-plots&quot; class=&quot;section level2&quot;&gt; &lt;h2&gt;Including Plots&lt;/h2&gt; &lt;p&gt;You can also embed plots, for example:&lt;/p&gt; &lt;p&gt;&lt;img src=&quot;某个很长的路径&quot; width=&quot;672&quot; /&gt;&lt;/p&gt; &lt;p&gt;Note that the &lt;code&gt;echo = FALSE&lt;/code&gt; parameter was added to the code chunk to prevent printing of the R code that generated the plot.&lt;/p&gt; &lt;/div&gt; 不难发现，上面的代码段与源文档 first-rmd.Rmd 之间存在明确的文本对应关系。例如，在 R Markdown 文档 ## R Markdown 后的前两个段落中，我们有 This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: 在 HTML 文件中对应的段落为 &lt;p&gt;This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;a href=&quot;http://rmarkdown.rstudio.com&quot; class=&quot;uri&quot;&gt;http://rmarkdown.rstudio.com&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;When you click the &lt;strong&gt;Knit&lt;/strong&gt; button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:&lt;/p&gt; 我们还注意到，HTML 文件中的文本并不是照搬 R Markdown 文件，而是做了相应的替换。最显著的变化是，HTML 文件在两个段落的前后分别添加了 &lt;p&gt; 标签，这在 HTML 语法中表示一个单独的段落，而 R Markdown 文件中只在两个段落之间添加了空行，没有做其他的额外标识。再例如， R Markdown 中的 **Knit** 在 HTML 中变成了 &lt;strong&gt;Knit&lt;/strong&gt;, * 号变为在 HTML 中标识粗体的 &lt;strong&gt; 标签。这说明，R Markdown 的编译机制中存在一种自动的格式上的转换过程，它能将 R Markdown 中的格式标记翻译为 HTML 中相应的格式表达方法。对 PDF 编译感兴趣的读者如果查看输出的 .tex 文件，会发现 **Knit** 被转换为了 \\textbf{Knit}，即 TeX 中粗体的表示方法。我们发现，R Markdown 可以让我们使用同一套”源格式”导出至不同的输出格式。这种统一的源格式就是我们将在下一节学习的 Markdown 语法。这里，我们可以把 Markdown 看作一种中介格式，在源文档中告诉 R Markdown “这里需要一个粗体，这里添加下划线，这里是一段引用”，至于这些格式具体在未知的输出格式中如何表现，就由 R Markdown 在最终的编译中决定了。 另外值得注意的是 R 代码的格式。以第一段代码 summary(cars) 为例，在 R Markdown 源文档中，该段代码的的格式为 ```{r} summary(cars) ``` 其中，开头的```{r} 和末尾的三个 ``` 是特殊的标识符，让 R Markdown 在编译时能区分哪段是文本，哪段是需要运行的代码。读者可能在源文档中注意到 RStudio 为这样的代码段提供了高亮支持，这说明 ```{r} 对 R Markdown 而言有特殊意义，不是一般的文本符号。当 R Markdown 发现了这样符号定义的代码之后，编译机制就能在适当时候调用相应编程语言的引擎（例如 R）并保存它们的输出结果，转换为相应的格式，最终在 HTML 中体现为 &lt;pre&gt;&lt;code&gt; ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 &lt;/code&gt;&lt;/pre&gt; 同理，当下一个代码段 plot(pressure) 的输出结果是图片时，R Markdown 也能正确地使用 HTML 标准中对应的 &lt;img&gt; 标签。读者还可能发现该段代码没有出现在 HTML 网页中，只有生成的图片被留了下来。这是因为我们在 ```{r} 中制定了 echo = FALSE 选项，它告诉 R Markdown 仅保留该段代码的输出结果，而隐藏代码本身。本书的后续章节将介绍更多类似的代码段选项，进一步定制 R Markdown 文档的输出。 3.2 Markdown 语法 3.3 使用 R 代码 3.4 输出格式 3.5 R Markdown 的编译过程 "],["document.html", "第 4 章 常用文档格式", " 第 4 章 常用文档格式 Markdown 在发明之初的主要目的就是简化 HTML 内容的书写方式。例如要表示一个无序列表中的项，用 HTML 来写是 &lt;ul&gt;&lt;li&gt;text&lt;/li&gt;&lt;/ul&gt;，而用 Markdown 来写则只需要 - text；又如要表示一段引用文字，用 HTML 来写是 &lt;blockquote&gt;text&lt;/blockquote&gt;，用 Markdown 来写则只需要 &gt; text。 Pandoc 大大扩展了 Markdown 的语法。更重要的是，Pandoc 使得将 Markdown 文档转换为多种输出格式成为可能。在本章中，我们将介绍各种文档输出格式的功能。在接下来的两章中，我们将分别介绍演示文稿格式和其他 R Markdown 扩展。 简单说来，要论从 R Markdown 到各种文档之间总共分几步？答案是 2 步。 R Markdown –&gt; Markdown，由 knitr 完成； Markdown –&gt; 不同格式文档，由 Pandoc 完成。 "],["html-document.html", "第 5 章 从 R Markdown 到 HTML 文档 5.1 目录和标题 5.2 主题和样式 5.3 图片和数据框 5.4 组件和内容", " 第 5 章 从 R Markdown 到 HTML 文档 因为 Markdown 技术在设计之初的输出格式就是 HTML，所以 HTML 文档不仅仅是最常用 R Markdown 输出格式，同时也拥有最丰富的功能。 前面提过，R Markdown 生成 HTML 文档的过程有一个中间步骤，就是 Markdown + HTML 模板。HTML 模板包括预定义的文档结构、 CSS 样式表和 JavaScript 动态网页功能等，所以最终渲染得到的 HTML 文档的一些功能可能依赖于特定 HTML 模板才能实现。 默认情况下，R Markdown 的 HTML 文档使用 rmarkdown::html_document 模板。除此之外， rmarkdown 之外的其它软件包也提供了各种不同类型的 HTML 模板文件（如 bookdown::html_document2，pagedown::html_paged 等）。因此，在这一部分我们先从 R Markdown 到 html_document 文档开始。 要创建一个 html_document，只需要在 R Markdown 的开头加入 YAML 格式的元数据。 --- title: &quot;文档标题&quot; author: &quot;作者&quot; date: &quot;创建时间&quot; output: html_document --- 在元数据中，还可以加入各种各样设置，从而改变文档的格式。 5.1 目录和标题 5.1.1 显示目录 在开头的元数据中，使用 toc: true 可以打开文档的目录。目录会从 HTML 的标题自动生成，目录的层级由 toc_depth 的值确定（默认为 3）。例如： --- title: &quot;标题&quot; output: html_document: toc: true toc_depth: 2 --- 在上面的例子中，目录中将包含 HTML 文档中的一级标题和二级标题。 5.1.2 悬停目录 当把 toc_float 设为 true 的时候，目录会在侧边栏悬停。这样你就可以随时借助目录在一篇比较长的文档中跳转了。 --- title: &quot;标题&quot; output: html_document: toc: true toc_float: true --- 通过改变 toc_float 的选项，可以控制侧边栏的折叠和动画。其中： collapsed （默认为 true）控制文档第一次打开时目录是否被折叠。如果为 true 则只显示高级别的标题（二级标题及以上元素）； smooth_scroll （默认为 true）控制页面滚动时，标题是否会随之变化。 --- title: &quot;标题&quot; output: html_document: toc: true toc_float: collapsed: false smooth_scroll: false --- 5.1.3 显示标题编号 使用 number_sections 可以在标题开头加上编号。一级标题编号为 “1 一级标题”，二级标题为”1.1 二级标题”。 --- title: &quot;标题&quot; output: html_document: toc: true number_sections: true --- 5.1.4 使用标签页 在 HTML 文档中使用标签页非常简单，只需要在标题后附加 {.tabset} 标签即可。 ## Quarterly Results {.tabset} ### By Product (tab content) ### By Region (tab content) 在此基础上，添加相关的额外标签还可以控制标签的样式和行为。其中： .tabset-fade 将为标签切换过程加入淡入淡出的动画效果； .tabset-pills 将为标签文字加上预设的 “pill”样式（图 5.1）。 图 5.1: 标签的默认样式及“pill”样式 5.2 主题和样式 5.2.1 可选主题 为了满足颜值党的差异化需求，html_document 自带了多个不同的主题。这些主题来自于 Bootswatch。可用的主题名称包括 default，cerulean，journal，flatly，darkly，readable，spacelab，united，cosmo，lumen，paper，sandstone，simplex 和 yeti 等等。 主题使用 theme 参数来指定，例如： --- title: &quot;标题&quot; output: html_document: theme: united --- 如果设置为 theme: null，那么将不会应用任何主题，此时你可以通过指定自定义的 CSS 样式表来进行格式化。 --- title: &quot;标题&quot; output: html_document: theme: null css: style.css --- 5.2.2 代码高亮 代码高亮也有可选的多种样式，包括 default，tango，pygments，kate，monchrome，espresso，zenburn，haddock，breezedark 和 textmate 等。 在元数据中，使用 highlight 参数指定代码高亮样式。 --- title: &quot;标题&quot; output: html_document: highlight: tango --- 跟上面的 theme 属性一样，highlight 也可以设为 null，这样的话代码将不显示高亮。 5.2.3 自定义样式表 不论有没有应用主题和代码高亮，你都可以使用 css 参数指定附加样式表。附加样式表中的定义可以被应用到特定元素上去。 --- title: &quot;标题&quot; output: html_document: theme: null highlight: null css: styles.css --- 在 styley.css 中，假设我们定义了两个新样式如下： #nextsteps { color: blue; } .emphasized { font-size: 1.2em; } 则可以通过下列方式应用这个样式： ## 这里强调一下下一步 {#nextsteps .emphasized} 如果要应用多个 CSS 配置文件，可以这样写： output: html_document: css: [&quot;style-1.css&quot;, &quot;style-2.css&quot;] 5.2.4 通过 CSS 代码块定义样式 除了像上面那样导入一个预定义的样式表，你还可以直接在 R Markdown 中添加新的 CSS 定义。这种方法非常适合于个别定义。如果你的 CSS 代码很多，或者想要在其它 R Markdown 中使用同样的定义，可能放在自定义的样式表文件中更加合适（参见 5.2.3）。 --- title: &quot;对代码块使用自定义的 CSS 样式&quot; output: html_document --- 首先定义一个新样式 `watch-out`。 ```{css, echo=FALSE} .watch-out { background-color: lightpink; border: 3px solid red; font-weight: bold; } ``` 使用代码块属性 `class.source` 可以将新样式指定给这一区块。 ```{r class.source=&quot;watch-out&quot;} mtcars[1:5, &quot;mpg&quot;] ``` ## PhantomJS not found. You can install it with webshot::install_phantomjs(). If it is installed, please make sure the phantomjs executable can be found via the PATH variable. 图 5.2: 一个具有浅红色背景和深红色边框的代码块 5.2.5 使用丰富多样的内置 CSS 样式 大多数时候，你并不需要自己定义 CSS 样式，因为 HTML 内置的主题中已经包含了丰富且高级的内置样式。 默认情况下，R Markdown 输出的 HTML 文档中，已经内嵌了 Bootstrap 框架，因此可以使用一系列预定义的 CSS 样式。其中，可用的背景样式就包括 \"bg-primary\"，\"bg-success\"，\"bg-info\"，\"bg-warning\" 和 \"bg-danger\" 等。 只需要像上面那样，在代码块属性中使用 class.source 标签，就可以应用这些预定义的 CSS 样式。 --- title: 改变代码块的样式 output: html_document --- 当你对一个数据框取子集的时候，其输出跟选取的列的数目有关。 如果选取了 2 个以上的列，则输出仍然是一个数据库； 如果选取了 1 个列，则输出的结果将会是一个向量。 因此，我们对这个操作应用了 `bg-danger` 和 `bg-warning` 的样式。 ```{r class.source=&quot;bg-danger&quot;, class.output=&quot;bg-warning&quot;} mtcars[1:5, &quot;mpg&quot;] ``` 为了确保始终能够得到数据框，则需要添加 `drop = FALSE` 参数。 为了显示这个结果，我们应用了 `bg-success` 样式。 ```{r df-drop-ok, class.source=&quot;bg-success&quot;} mtcars[1:5, &quot;mpg&quot;, drop = FALSE] ``` 以上内容生成 HTML 文档后的样子如下图所示： ## PhantomJS not found. You can install it with webshot::install_phantomjs(). If it is installed, please make sure the phantomjs executable can be found via the PATH variable. 图 5.3: 在代码块上应用内置 CSS 样式 5.2.6 代码折叠 当 Knitr 的代码块参数 echo = TRUE 时，R 代码将会输出到最终生成的文档中。 如果你不需要显示源代码，可以直接设为 echo = FALSE。 如果你既想要保留代码但又让其默认不显示， 则可以通过 code_folding: hide 参数来实现。 --- title: &quot;Habits&quot; output: html_document: code_folding: hide --- code_folding: hide 将折叠所有的代码块，用户可以通过点击来查看折叠的代码。如果想让部分代码块在一开始就显示，则可以在代码块选项中使用 class.source = 'fold-show'。 --- title: &quot;代码的折叠和显示&quot; output: html_document: code_folding: hide --- ```{r} 1 # 折叠的 ``` ```{r class.source = &#39;fold-show&#39;} 2 # 显示的 ``` ```{r} 3 # 还是折叠的 ``` ## PhantomJS not found. You can install it with webshot::install_phantomjs(). If it is installed, please make sure the phantomjs executable can be found via the PATH variable. 图 5.4: 代码块的折叠和显示 这种操作也可以反向进行，如下配置即可： --- output: html_document: code_folding: show --- ```{r} 1 # 代码默认是显示的 ``` ```{r class.source = &#39;fold-hide&#39;} 2 # 这一块代码将被折叠 ``` 如图 5.4 所示，在页面和每一个代码块的右上方有一个按钮。页面右上方的按钮可以控制全部代码块的显示和隐藏，代码块右上方的按钮则可以控制对应代码块的显示和隐藏。 5.2.7 设置代码块内容可滚动 如果你想限制代码块的高度，特别是代码执行过程中输出内容的高度，还可以从相应内容的 CSS 样式上着手，即通过 class-output 和 class-source 来定义内容的高度。 下面是一个例子： --- title: 可以滚动的代码和输出 output: html_document --- ```{css, echo=FALSE} pre { max-height: 300px; overflow-y: auto; } pre[class] { max-height: 100px; } ``` 我们首先定义了上述 CSS 规则，用来限制代码块的高度。 ```{r} # 假如这里有 N 多行的代码 if (1 + 1 == 2) { # 然后再打印一个非常长的数据 print(mtcars) # 如果不够长的话，再加上这行注释可能就够了 } ``` 现在添加一个新的 CSS 类 `scroll-100`，以用来限制代码块的输出高度为 100 像素。 然后，将这个类赋值给代码块中的 `class.output` 参数。 ```{css, echo=FALSE} .scroll-100 { max-height: 100px; overflow-y: auto; background-color: inherit; } ``` ```{r, class.output=&quot;scroll-100&quot;} print(mtcars) ``` 因为代码块是位于 &lt;pre class=\"sourcecode\"&gt; 标签内的，所以 pre[class] 操作符将限制代码块的高度为不超过 100 像素。 而将 class.output 设为 scroll-100 则限制输出部分的高度为不超过 100 像素。 最终效果如下图所示： ## PhantomJS not found. You can install it with webshot::install_phantomjs(). If it is installed, please make sure the phantomjs executable can be found via the PATH variable. 图 5.5: 可以滚动的代码块 5.3 图片和数据框 5.3.1 设置图片的属性 下列参数可以调整生成的 HTML 文档中图片的属性： fig_width，fig_height 指定图片显示时的宽和高（默认为 7 × 5，单位英寸）。 fig_retina 开启视网膜屏幕优化（默认为 2，设为 null 时关闭优化）。 fig_caption 控制是否渲染图注。 dev 设置图片输出设备，默认为 png。你可以设置多个图片输出设备。 --- title: &quot;标题&quot; output: html_document: fig_width: 7 fig_height: 6 fig_caption: true dev: c(&quot;png&quot;,&quot;pdf&quot;) --- 在代码框属性中，你仍然可以通过 fig.height，fig.width，fig.asp 等参数来指定生成图片的高度、宽度和宽高比。 5.3.2 插入外源图片 虽然在 R Markdown 中可以使用 Markdown 语法和 HTML 语法插入图片，但是我们推荐使用 knitr::include_graphics() 来插入外源图片。例如： ```{r} knitr::include_graphics(&quot;https://r-project.org/Rlogo.png&quot;) ``` 使用这种方法插入外源图片，可以方便的添加图注（使用 fig.cap 参数），以及设置图片的宽高等属性。 图 5.6: 插入外源图片的推荐方式 5.3.3 输出数据框 通过 df_print 参数，你可以调整数据框的输出格式。可用的参数如表 5.1 所示。 表 5.1: html_document 可以被设置的 df_print 参数及其对应的含义。 取值 说明 default 调用 print.data.frame 的通用方法 kable 使用 knitr::kable 函数 tibble 使用 tibble::print.tbl_df 函数 paged 使用 rmarkdown::paged_table 来创建一个分页的表格 5.3.4 分页打印数据框时的附加参数 若把 df_print 参数设为 paged，数据框将支持行列的分页，效果如图 5.7 所示。 --- title: &quot;Motor Trend Car Road Tests&quot; output: html_document: df_print: paged --- ```{r} mtcars ``` 图 5.7: HTML文档中分页显示的数据框 表 5.2 列出了这种情况下可以使用的附加参数。 表 5.2: 分页 HTML 表格的附加可用参数。 参数名 说明 max.print 显示的总行数 rows.print 一页显示的行数 cols.print 一页显示的列数 cols.min.print 最少显示几列 pages.print 下方显示几个页面导航的链接 paged.print 设为 FALSE 则不输出分页的表格 rownames.print 设为 FALSE 时不显示行的名称 这些参数可以在代码块中使用。 ```{r cols.print=3, rows.print=3} mtcars ``` 5.4 组件和内容 5.4.1 理解 HTML 文档的依赖关系 前面已经提过，R Markdown 输出的 HTML 文档时，依赖于软件包提供的 HTML 模板。 实际上，HTML 文档的样式和功能很大程度上依赖于一些 CSS 样式和 JavaScript 库的支持。 这里面包括 Bootstrap，JQuery 等优秀的开源项目。 默认情况下，R Markdown 输出的 HTML 文档是一个单一的 .html 文件。这是由 self_contained: true 控制的。.html 文件中，会使用 data: 存储包括 JavaScript、CSS、图片和视频在内的全部资料。这样的一个封装，使得用户可以像分享 PDF 或 Word 文档那样分享文件，同时享受超链接、动态效果等一系列 HTML 特性。 如果你指定 self_contained: false，那么 HTML 文档将会将自身的依赖文件单独存放。 --- title: &quot;Habits&quot; output: html_document: self_contained: false --- 默认情况下，在 .html 文件同一目录会生成同名的 _files 文件夹，存放相应的依赖文件。下面是默认情况下一份 HTML 文档所包含的依赖文件。 +---anchor-sections-1.0 +---bootstrap-3.3.5 | +---css | | \\---fonts | +---fonts | +---js | \\---shim +---header-attrs-2.5 +---highlightjs-9.12.0 +---jquery-1.11.3 \\---navigation-1.1 库文件夹的位置可以由 lib_dir: xxx 指定，例如： --- title: &quot;Habits&quot; output: html_document: self_contained: false lib_dir: libs --- 依赖文件的内容会随配置变化，例如当在 YAML 配置中加入 df_print: paged 之后，依赖文件中会多一个 pagedtable-1.1 的子文件夹出来。 显然，存放依赖的子文件夹依据 库名 + 版本号 的规则命名。要弄清楚库文件的全部特性，可能要对库本身有相当的理解才行。而 R Markdown 则是把最常用的功能整合提供给了我们。 当文档的内容比较少，同时又有多个类似的文档的时候，库文件所占的存储空间可能比你自己编写的内容还要大得多。这种情况下，将库文件统一存储在指定的 libs 文件夹，可以实现库文件公用。 另外，有些库文件不常用，或者文件太大，还可以通过库文件的服务器调用。例如下面要讲的 MathJax 库。 5.4.2 MathJax 库的配置 HTML 文档需要 MathJax 脚本来渲染 Latex 和 MathML 公式，调用 MathJax 的方式则可以通过 mathjax 参数来调整。 \"default\"：默认配置，会通过 HTTPS 链接从 RStudio 的 CDN 网络服务器上调用； \"local\"：与 self_contained: false 联合使用时，会将 MathJax 库文件保存在本地目录中； 设置一个 URL 链接，指向可用的 MathJax 库文件地址； null：完全不使用 MathJax。 例如，使用 MathJax 的本地拷贝可以如下配置： --- title: &quot;Habits&quot; output: html_document: mathjax: local self_contained: false --- 为 MathJax 配置一个新的可用来源。 --- title: &quot;Habits&quot; output: html_document: mathjax: &quot;http://example.com/MathJax.js&quot; --- 不使用 MathJax。 --- title: &quot;Habits&quot; output: html_document: mathjax: null --- 5.4.3 是否保留 Markdown knitr 处理 R Markdown 文件时，会先生成一个 Markdown 文件（*.md），随后再由 Pandoc 转换成 HTML 文档。如果需要保留这个 Markdown 文件，可以使用 keep_md 选项。 --- title: &quot;Habits&quot; output: html_document: keep_md: true --- 5.4.4 使用自定义的 HTML 模板 使用 template 选项，可以配置 Pandoc 转换时使用的模板。 --- title: &quot;Habits&quot; output: html_document: template: another_template.html --- Pandoc 模板遵循特定的格式，有关的进一步信息可以在 Pandoc 模板 页面获得。 下面是一个 HTML 模板的示例： &lt;html&gt; &lt;head&gt; &lt;title&gt;$title$&lt;/title&gt; $for(css)$ &lt;link rel=&quot;stylesheet&quot; href=&quot;$css$&quot; type=&quot;text/css&quot; /&gt; $endfor$ &lt;/head&gt; &lt;body&gt; $body$ &lt;/body&gt; &lt;/html&gt; 这其中包括一些变量，如 $title$，$body$ 等。这些变量由 Pandoc 定义，完整的变量列表参见这里。 这样的 HTML 模板使得高度定制化的输出成为可能。例如，你可以在 &lt;head&gt; 区域加入任意的 CSS 样式， JavaScript 代码，以及其它的开源库。 另外，还可以定义一些新变量来控制文档的格式化。例如，定义一个布尔值 draft 来确定文档是一个草稿还是最终版本。 &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; .logo { float: right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;logo&quot;&gt; $if(draft)$ &lt;!-- use draft.png to show that this is a draft --&gt; &lt;img src=&quot;images/draft.png&quot; alt=&quot;Draft mode&quot; /&gt; $else$ &lt;!-- insert the formal logo if this is final --&gt; &lt;img src=&quot;images/logo.png&quot; alt=&quot;Final version&quot; /&gt; $endif$ &lt;/div&gt; $body$ &lt;/body&gt; draft 在 YAML 元数据中赋值。 --- title: &quot;An Important Report&quot; draft: true output: html_document: template: my-template.html --- 说明：rmarkdown 软件包默认使用自带的 HTML 模板，一些方面与 Pandoc 默认的模板存在差异。如果有 template: null 的话，则 Pandoc 的模板会被使用。 5.4.5 包含其它文件 使用 includes 选项，可以在 HTML 文档的不同位置嵌入其它的 HTML 格式内容。可选的位置包括在 HTML 文档的 header、body 前/后等。 --- title: &quot;Habits&quot; output: html_document: includes: in_header: header.html before_body: doc_prefix.html after_body: doc_suffix.html --- 这种方式可以很方便的为文档加入一些第三方功能和公用的元件。例如在 in_header 中导入预定义的 CSS 样式表和 Javascript 脚本，在 before_body 中加入导航栏，在 after_body 中加入一个底栏等。 下面的例子中，即添加了一个简单的底栏。将其中内容保存到一个 HTML 文件中，放在 after_body 后面即可。 &lt;div class=&quot;footer&quot;&gt;Copyright &amp;copy; R Markdown 指南 2021&lt;/div&gt; 除了以上几种常用的位置，你还可以在任意地方插入 HTML 内容。实现这一功能的途径至少有两种。 一是使用 htmltools::includeHTML() 方法： ```{r, echo=FALSE, results=&#39;asis&#39;} htmltools::includeHTML(&#39;file.html&#39;) ``` 二是使用 xfun::file_string() 方法： ```{r, echo=FALSE, results=&#39;asis&#39;} xfun::file_string(&#39;file.html&#39;) ``` 需要注意的是，导入的 HTML 文件必须是 HTML 片段，而不能是一个完整的 HTML 文档。完整的 HTML 文件中有 &lt;html&gt; 标签，解析时会造成错误。比如下面就是一个无效的例子： &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; Parent HTML file. &lt;!-- htmltools::includeHTML() below --&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; Child HTML file. &lt;/body&gt; &lt;/html&gt; &lt;!-- included above --&gt; &lt;/body&gt; &lt;/html&gt; 5.4.6 生成 HTML 片段 HTML 片段是一个不完整的 HTML 文件，这种片段适合用于嵌入其它的网页或者内容管理系统（如博客）中。HTML 片段也不自带主题和代码高亮，而通过继承的方式使用其嵌入文件或系统的设置。这样的 HTML 片段，也非常适合用于包含在其它文件中（参见 5.4.5）。 --- output: html_fragment --- 下面是一个 HTML 片段的例子： &lt;p&gt;HTML 片段可以有标题和代码区域，但是不包含任何 CSS 定义。&lt;/p&gt; &lt;pre class=&quot;r&quot;&gt;&lt;code&gt;head(mtcars)&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code&gt;## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1&lt;/code&gt;&lt;/pre&gt; 将这些内容保存为一个 HTML 文件，导入此处，则效果如下所示： HTML 片段可以有标题和代码区域，但是不包含任何 CSS 定义。 head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 HTML 片段的内容到此结束。 5.4.7 使用自定义的浏览器图标 通过在 in_header 部位导入 HTML 内容，可以为 HTML 文档设定一个自定义的浏览器图标。 将下面的内容保存到一个名为 header.html 的文档中。 &lt;link rel=&quot;shortcut icon&quot; href=&quot;{path to favicon file}&quot; /&gt; 然后通过 includes 导入文件的内容，则可以改变浏览当前文档时的浏览器图标。 output: html_document: includes: in_header: header.html 5.4.8 共用 YAML 配置文件 当前目录中的 _output.yml 文件是一个配置文件，其中的设置可以被目录下所有的 R Markdown 文档公用。需要注意的是，该文件中的内容不需要使用--- 和 output 标签。 如下所示： html_document: self_contained: false theme: united highlight: textmate 而不应该写成下面这种样子： --- output: html_document: self_contained: false theme: united highlight: textmate --- 5.4.9 嵌入 Rmd 源文件 当你分享一个 R Markdown 生成的 HTML 文档给他人的时候，对方可能还想找你索取 .Rmd 源文件。在头文件中配置 code_download 参数可以在 HTML 文档中嵌入源文件。 output: html_document: code_download: true 打开 code_download 选项后，页面中会出现一个下载按钮，点击下载按钮即可获得源文件。 5.4.10 嵌入其它文件 嵌入 .Rmd 源文件可能还不足以重现 R Markdown 中结果，通常还会需要原始数据等其它内容。要将这些内容嵌入 HTML 文档中，也是很容易实现的。 这一功能通过 xfun 软件包(Xie 2021c) 实现，依赖于 htmltools 和 mime 软件包。要使用这一功能，首先确保这两个软件包可用。 xfun::pkg_load2(c(&#39;htmltools&#39;, &#39;mime&#39;)) 现在，就可以随意嵌入各种文件了。 ```{r echo=FALSE} # 不但可以嵌入一个文件 xfun::embed_file(&#39;source.Rmd&#39;) # 还可以嵌入多个文件 xfun::embed_files(c(&#39;source.Rmd&#39;, &#39;data.csv&#39;)) # 甚至一个目录也不在话下 xfun::embed_dir(&#39;data/&#39;, text = &#39;Download full data&#39;) ``` 不仅如此，你还可以编程技巧嵌入所需的文件。 # 嵌入当前目录下所有的 Rmd 和 csv 文件 xfun::embed_files(list.files(&#39;.&#39;, &#39;[.](Rmd|csv)$&#39;)) 说明：当嵌入多个文件时，其工作原理是：首先将这些文件压缩成 Zip 格式，然后将 Zip 文件嵌入到 HTML 文档中。 "],["PDF-document.html", "第 6 章 PDF 文档 6.1 安装 TinyTex 6.2 从 R Markdown 到 PDF 文档 6.3 在 PDF 文档中使用中文的注意事项 6.4 LaTeX 选项", " 第 6 章 PDF 文档 这一章讲述将 rmarkdown 输出为 PDF 的一些技巧。 PDF 是便携式文档格式（Portable Document Format）的缩写，这是一种常见的文档格式， 特别是在文件、学术论文中广泛使用。它具有文件体积小、保真度高和安全的特点。 R Markdown 并不能直接输出 PDF 文档，而是会输出 LaTeX 文件，LaTeX 文件经过处理后生成 PDF。 因此，使用 R Markdown 输出 PDF 文件时，可以充分发挥 LaTeX 的优势。在需要的时候，可以直接使用 LaTeX 代码编写内容，应用 LaTeX 的包和模板，添加标题、脚注、子图等。 不过，LaTeX 技术对于大多数人可能都还比较陌生，而在生成 PDF 文档的过程中，很多问题都跟 LaTeX 的 配置有关。这几乎是不可避免的，因此在开始正式的内容前，我们需要来了解一下常见问题的解决方法。 6.1 安装 TinyTex LaTex 有很多发行版，如 MiKTex，MacTeX， TeX Live 等，我们建议 R Markdown 的用户使用 TinyTeX。TinyTex 的开发者与 R Markdown 都是谢益辉，因而是最佳拍档。它占用空间小，配置灵活。 knitr::include_graphics(&quot;images/logo-tinytex.png&quot;) 要安装 TinyTex，只需要在 R 语言终端输入两条命令即可1。 # 安装 tinytex install.packages(&quot;tinytex&quot;) tinytex::install_tinytex() 6.1.1 安装 LaTeX 组件 LaTex 有非常多的组件，也被称为包（“package”）。tinytex::install_tinytex() 只安装了 必须的一些组件，在实际使用过程中经常会出现缺少组件的错误。 如果你知道包的名称，那么可以直接使用下面的命令安装。这里值得注意的是，对于国内的用户来说， 通常需要设定一下 LaTeX 软件仓库的位置。下面的例子中，使用了清华大学的 TeX Live 镜像。 # install required Latex package tinytex::tlmgr_repo(url = &quot;https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet&quot;) tinytex::tlmgr_install(c(&#39;pgf&#39;, &#39;preview&#39;, &#39;xcolor&#39;)) 如果不知道包的名称也没有关系，tinytex 也提供了相应的函数来帮助你从报错信息中找到解决方法。 tinytex::parse_install() 提供两种方法，第一种是通过准确的错误提示，第二种是通过分析 log 文件。 如果嫌 log 太长或者找不到具体提示信息，还可以使用第二种办法。 # 假如有相关报错信息 &quot;! LaTeX Error: File `preview.sty&#39; not found.&quot; tinytex::parse_install(text = &quot;! LaTeX Error: File `preview.sty&#39; not found.&quot;) # 假如我们有一个错误 log 名为 tex.log tinytex::parse_install(log = &quot;tex.log&quot;) 6.2 从 R Markdown 到 PDF 文档 接下来我们进入正题。要输出 PDF 文档，只需要在 R Markdown 开头的 YAML 配置中指定 pdf_document 即可。 --- output: pdf_document --- 只需要这样一个改动，你就可以得到一份 PDF 文档。 6.3 在 PDF 文档中使用中文的注意事项 如果这份 PDF 中仅含有英文，那么不需要做额外的设置。 但是对于中文用户而言，可能会出现错误。这是因为，PDF 所依赖的 LaTeX 系统对中文的支持与 HTML 不同，需要做一些合适的设置。 下面就是一份中文 PDF 文档的示例。 import_example(&quot;examples/PDF-document-in-chinese.Rmd&quot;) --- title: &quot;这是一个 R Markdown 生成的 PDF 文档&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document: latex_engine: xelatex header-includes: - \\usepackage{ctex} --- 既然你在看这本书，想必你想制作的 PDF 文档难免会包括中文。 要想让 PDF 更好的支持中文，需要做一些额外的设置。 包括设置一个对 Unicode 支持更好的 `xelatex` 引擎，以及在 PDF 文档开始的配置部分 使用中文语言支持软件包 `ctex`。 我们接下来将会分别介绍这些功能。 将这份 R Markdown 编译后，将会生成一份 PDF 文档。 import_example_result(&quot;examples/PDF-document-in-chinese.Rmd&quot;) 这个配置中的内容将会在后面解释。 6.3.1 显示目录 使用 toc 在 PDF 文档中加入目录，toc_depth 控制目录的深度。这点与 HTML 文档的用法一致2。 --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： toc: true toc_depth: 2 --- 如果 toc_depth 没有指定，则默认索引到二级标题（在 HTML 文档中默认索引到三级标题）。 使用 number_sections 可以在标题前面加入编号。 --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： toc: true toc_depth: 2 number_sections: true --- 6.3.2 图片相关的配置 fig_width 和 fig_height 用于控制图片默认的宽和高（默认为 6.5 x 4.5 英寸）。 fig_crop 控制 pdfcrop 的效果，功能是帮助我们去掉图片边缘的空白（默认为 true）。 pdfcrop 是一个 LaTeX 组件，默认并没有被 tinytex 安装。我们推荐用户运行 tinytex::tlmgr_install(\"pdfcrop\") 来安装它。同时，pdfcrop 依赖于系统中的存在的 ghostscript，你还需要安装 ghostscript 才能正常使用 pdfcrop。 fig_caption 控制是否为图片添加图注（默认为 true）。 dev 控制用于渲染图片的图像设备（默认为 pdf）。 --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： fig_width: 7 fig_height: 6 fig_caption: true --- 6.3.3 打印数据框 通过配置 df_print，可以调整打印数据框的格式（表 6.1）。 表 6.1: 输出 PDF 时 df_print 可选的值。 配置 说明 default 调用 print.data.frame 泛型函数 kable 使用 knitr::kable() 函数 tibble 使用 tibble::print.tbl_df() 函数 一个自定义函数 使用自定义函数创建一个表格。参见 ?? --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： df_print: kable --- 6.3.4 代码高亮 与 HTML 文档相同，这里可用 highlight 参数配置代码高亮的样式（参见 5.2 部分内容）。例如： --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： highlight: tango --- 6.4 LaTeX 选项 很多 LaTeX 的配置，可以通过头部 YAML 的设定传递给 PDF 文档。 6.4.1 通用文档部件 一个 LaTeX 文档的结构大概是这样子： \\documentclass{article} % preamble \\begin{document} % body \\end{document} 在这个文档中，你首先通过 \\documentclass{} 指定了文档的类，然后在 preamble 部分导入一些 LaTeX 的包（组件）和进行必要的设置，接下来在 \\begin{document} 后开始文档的主体内容。 一个 Markdown 文档基本上是 body 部分的内容。 如果需要在 preamble 部分加入一些内容，则可以使用 includes 选项。该选项包括 3 个 部分：in_header，before_body 和 after_body。每一个都支持一个或多个文件路径。 in_header 指定文件的内容将会被添加到 preamble 部分，before_body 和 after_body 指定文件的内容会分别被添加到 body 的前面和后面。 举例来说，下面的一个小技巧可以将正文中的链接地址以脚注的形式显示在 PDF 文档中， 这对于打印出来的文本而言，避免了无法看到链接地址的尴尬。我们将这几行代码保存为 tex 文件， 导入到 preamble 部分，就可以实现这一功能。 % you may want to save a copy of \\href before redefining it % \\let\\oldhref\\href \\renewcommand{\\href}[2]{#2\\footnote{\\url{#1}}} 如果保存的文件名为 preamble.tex 则可以通过下面的形式将其添加到所有的 PDF 页面中。 output: pdf_document: includes: in_header: &quot;preamble.tex&quot; 不过，Pandoc 默认的 LaTeX 模板中已经内嵌了这一用法，所以实际上你可以直接设置 links-as-notes 为 true 即可。 output: pdf_document: links-as-notes: true 在本书的 PDF 版本中，就使用了这种方法来添加页眉、页脚等内容。 6.4.2 选择 LaTeX 模板 通过 template 可以指定输出 PDF 文档时采用的 LaTeX 模板。 --- output: pdf_document: template: quarterly-report.tex --- 6.4.3 配置 LaTeX 模板的参数 每个 LaTeX 模板会有很多参数，用来指定文档的语言、字体、文字大小、页边距等内容。 表 6.2 列示了常见的一些参数，完整的参数则可以在 Pandoc 手册 中查看。 表 6.2: 在 YAML 配置中可用的 LaTeX 变量 变量名称 说明 lang 文档的语言代码 fontsize 文字大小 （如 10pt，11pt，12pt） documentclass LaTeX 文档类型 （如 article） classoption 文档类型的选项（如 oneside） geometry 页边距（如 margin=1in） mainfont, sansfont, monofont, mathfont 文档的字体（仅在使用 xelatex 和 lualatex 时可用） linkcolor, urlcolor, citecolor 内部链接、外部链接和引文链接的颜色 使用这些参数的时候，需要将其写在 YAML 头信息的最顶层，例如： --- title: &quot;这是一个PDF&quot; output: pdf_document fontsize: 11pt geometry: margin=1in --- 6.4.4 使用 LaTeX 包处理引用 默认情况，文档中的引用使用 pandoc-citeproc 来处理，这种方法不限制输出文档的类型，适用性最广。 不过，在 LaTeX 系统中有更加优秀的引用工具，例如 natbib 和 biblatex。 如果想使用它们，只需要在 citation_package 中指定即可。 --- output: pdf_document: citation_package: natbib --- 6.4.5 LaTeX 的渲染引擎 PDF 文档默认通过 pdflatex 渲染。其它可用的引擎还包括 pdflatex，xelatex和lualatex等。 不同的引擎可通过 latex_engine 来选择。 一般情况下，使用 xelatex 或者 lualatex 的主要理由是它们对 Unicode 的支持更加优秀， 以及它们更容易使用系统中已有的字体3。 --- output: pdf_document: latex_engine: xelatex --- 6.4.6 保留生成的 TeX 中间文件 R Markdown 首先转化为 TeX 文件，然后才能转化为 PDF 文档。默认情况下，PDF 文档生成后，TeX 文档将会被删除。通过改变 keep_tex 的设置，可以保留生成的 TeX 文档（可用于向某些杂志投稿）。 --- output: pdf_document: keep_tex: true --- TinyTex 与 tinytex 并不是一个东西。前者是一个 LaTeX 发行版，后者是一个用来安装和维护 前者的 R 语言软件包。↩︎ 实际上很多配置的名称都保持一致，但是也有不少会跟文档格式有关。如果有个配置没有效果，可能会跟配置的适用范围有关。↩︎ 在 https://tex.stackexchange.com/q/3393/9128 和 https://tex.stackexchange.com/q/36/9128 这两个网页中对这一问题有更多的解释。↩︎ "],["presentation.html", "第 7 章 演示文稿 7.1 R Markdown 基础幻灯片 7.2 Xaringan 幻灯片", " 第 7 章 演示文稿 本章讲述使用 R Markdown 生成演示文稿（俗称“PPT”）的技巧。 幻灯片可以被看做一个精简的文档，它的基本单位是单独的一页，每页含有标题、内容和其它元素。 R Markdown 文档可以直接输出为 HTML 或者 PDF 格式的幻灯片，并且可以通过额外的软件包丰富 幻灯片的具体样式。在这一部分，我们首先介绍 R Markdown 基础幻灯片的使用，然后介绍使用 xaringan 创建的更加精美的幻灯片。 7.1 R Markdown 基础幻灯片 使用基础幻灯片不需要安装额外的包。 R Markdown 支持 4 种不同样式的幻灯片，分别是 ioslides，Slidy，Beamer 和 PowerPoint。 在 RStudio 中，你可以通过菜单中的 “New File -&gt; R Markdown…” 打开如下一个窗口（图 7.1），然后选择 “OK” 后即可新建一个幻灯片。 knitr::include_graphics(&quot;images/rmd-presentation-popup.png&quot;) 图 7.1: 新建 R Markdown 时可选的幻灯片格式 7.1.1 ioslides 幻灯片 我们首先看 ioslides 幻灯片。新建的幻灯片，也是一个 R Markdown 文档，在它的头部 YAML 中， output: ioslides_presentation 设定了其输出格式。 import_example(&quot;examples/ioslides-presentation.Rmd&quot;) --- title: &quot;Ioslides Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: ioslides_presentation --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## R Markdown This is an R Markdown presentation. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. ## Slide with Bullets - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` 这个文档经过编译后，得到的幻灯片如图 7.2 所示。 由此可见，在 R Markdown 幻灯片中，源文件中的 ## 代表一张幻灯片的开头和标题， ## 后面的内容是这一张幻灯片中的内容。R Markdown 会自动将命令和输出的内容添加到幻灯片中。 knitr::include_graphics(&quot;examples/ioslides-presentation-screenshot.png&quot;) 图 7.2: 新建文件编译后生成的 ioslides 幻灯片 除了 ##，使用 --- 也能开始一张新的幻灯片，并最终生成一个不带标题的幻灯片。 另外，还可以通过 “|” 来为幻灯片添加副标题。例如下面的例子： ## Getting up | What I like to do first thing 7.1.1.1 使用快捷键控制显示模式 ioslides 幻灯片支持以下快捷键更改播放时的模式： 'f'：全屏模式，幻灯片将会占满屏幕。 'w'：宽屏模式，幻灯片将会以宽屏模式显示。 'o'：预览模式，幻灯片将会缩小并同时显示多个。 'h'：启用代码高亮模式，突出显示指定的几行代码。具体使用方法下面介绍。 'p'：显示演讲者备注，演讲者备注需要以指定的方式添加。具体使用方法下面介绍。 按下 'Esc' 键将会退出以上所有模式。 7.1.1.2 依次显示列表中的项目 使用 incremental 选项可以控制列表项目依次出现，相当于添加了简单的播放动画。 import_example(&quot;examples/ioslides-presentation-increment-bullets.Rmd&quot;) --- output: ioslides_presentation --- # ioslides 幻灯片 {data-background=ioslides-presentation.png data-background-size=cover} 一级标题产生了一个背景为灰色的幻灯片，我们为它加入了背景图片。 ## 列表项的内容 | 这里加入了一个副标题 默认情况下，整个幻灯片将会同时显示。 - Bullet 1 - Bullet 2 - Bullet 3 ## 列表项的内容 {.smaller} 但是 `&gt;` 可以作用于列表，这样以下内容将会在播放时依次出现（点击鼠标或者使用键盘）。 &gt; - Bullet 1 &gt; - Bullet 2 &gt; - Bullet 3 ## 下面的内容将会依次显示 {.build} 幻灯片标题后面的 `{.build}` 将会为这张幻灯片添加一个效果。首先显示这一段话，然后才显示下面的列表。 - 这个列表中的项目并不会依次显示 - 而是会作为一个整体出现 接下来的列表，因为使用了 `&gt;` 方法，其中的项目则可以依次出现。 &gt; - 先出现这个 &gt; - 然后才是这个 ## Future Steps {#future-steps .emphasized} 在 `style.css` 中，添加下列定义。 ```{css} #future-steps { color: blue; } .emphasized { font-size: 1.5em; } ``` 这几个字特别重要。 ## 代码高亮 大家看，这两步运算非常关键。 ```{r} cat(&#39;接下来进入计算过程&#39;) ### &lt;b&gt; x &lt;- 10 y &lt;- x * 2 ### &lt;/b&gt; cat(&#39;计算完毕&#39;) ``` 为所有幻灯片添加这样的效果有时候显得有点过分，所以 R Markdown 还提供了针对个别幻灯片 添加依次呈现效果的方法，即在前面加上一个 &gt; 号。 &gt; - Bullet 1 &gt; - Bullet 2 7.1.1.3 幻灯片的大小 在配置中使用 widescreen 可以将幻灯片样式改为宽屏。 --- output: ioslides_presentation: widescreen: true --- 7.1.1.4 幻灯片播放速度 ioslides 幻灯片翻页时会有淡入淡出的效果，使用 transition 可以控制效果的时长。 transition 设置为 \"default\"，\"slower\"，\"faster\"，或者一个以秒为单位的数字（如0.5）均可。如下所示： --- output: ioslides_presentation: transition: slower --- 7.1.1.5 依次显示幻灯片元素 每一张幻灯片的标题都可以加上 .build 属性，这样幻灯片的内容在播放的时候将会一块块的依次显示出来。 这一点与 incremental 属性有些类似，不过后者针对的是列表中的项目，而前者针对的是 一段话，一整个列表。 ## 下面的内容将会依次显示 {.build} 首先显示这一段话，然后才显示下面的列表。 - 这个列表中的项目并不会依次显示 - 而是会作为一个整体出现 接下来的列表，因为使用了 `&gt;` 方法，其中的项目则可以依次出现。 &gt; - 先出现这个 &gt; - 然后才是这个 7.1.1.6 设置幻灯片的背景图像 幻灯片中可以使用 data-background 添加背景图片，并使用其它的相关属性来 配置背景图片的行为，如 data-background-size， data-background-position， data-background-repeat 等等。 ## 添加背景图像 {data-background=foo.png data-background-size=cover} 这些配置来自于 CSS 中图片的属性，background，background-size，background-position， 以及 background-repeat 等。你可能需要对 CSS 有所了解，才能准确把握这些属性的用途。 7.1.1.7 自定义 CSS ioslides 幻灯片本质是一个 HTML 文档，可以通过自定义 CSS 来设定幻灯片中不同元素的样式。 要在幻灯片中附加一个自定义样式表，可以使用 css 属性。 --- output: ioslides_presentation: css: styles.css --- 为某一张幻灯片中添加样式的方式，也是通过大括号语法完成的。 ## Future Steps {#future-steps .emphasized} 这张幻灯片中的所有元素将会应用 CSS 定义的样式。 在 style.css 中，添加下列定义。 #future-steps { color: blue; } .emphasized { font-size: 1.2em; } 这种方式并不会影响幻灯片的标题，而是会影响这一张幻灯片中其它内容。 最终，这张幻灯片中所有的文字都会显示为蓝色、120% 的大字号。 7.1.1.8 突出显示部分代码 为了强调关键代码的作用，可以使用特定的注释来高亮它们。例如： ### &lt;b&gt; x &lt;- 10 y &lt;- x * 2 ### &lt;/b&gt; 在播放时，当按下键盘上的快捷键 'h' 时，高亮的代码将会突出显示，其它部分的代码则会变淡。 7.1.1.9 添加 LOGO 使用 logo 可以为幻灯片添加一个 LOGO 图片。默认情况下，这个 LOGO 将会以 85 x 85 像素显示在标题幻灯片上，并且缩小后显示在后面每一张幻灯片的左下角。 --- output: ioslides_presentation: logo: logo.png --- 使用自定义的 CSS 可以修改首页 LOGO 的显示效果。例如： .gdbar img { width: 300px !important; height: 150px !important; margin: 8px 8px; } .gdbar { width: 400px !important; height: 170px !important; } 左下角的 LOGO 显示样式同样可以使用 CSS 定义。例如： slides &gt; slide:not(.nobackground):before { width: 150px; height: 75px; background-size: 150px 75px; } 7.1.1.10 幻灯片的布局 如果想居中显示幻灯片的内容，可以在标题后面加入 .flexbox 和 .vcenter 的属性。 ## 统统居中显示 {.flexbox .vcenter} 使用 CSS class 的方法为美化幻灯片非常灵活。但是在标题中应用样式不能精确到一张 幻灯片中的某个具体元素。因此要实现幻灯片的复杂布局，只能使用类似 HTML 的语法。 居中显示某一段文字，可以采用下面的语法。 &lt;div class=&quot;centered&quot;&gt; This text is centered. &lt;/div&gt; 如果要以左右两栏的形式展示某一张幻灯片中的内容，可以使用下面的语法4。 &lt;div class=&quot;columns-2&quot;&gt; ![](image.png) - Bullet 1 - Bullet 2 - Bullet 3 &lt;/div&gt; 7.1.1.11 文字颜色 使用 HTML 语法还可以修改其它的属性，比如文字的颜色。只需要将颜色以 CSS 类的形式赋值给元素即可。例如： &lt;div class=&quot;red2&quot;&gt; This text is red &lt;/div&gt; 可用的颜色包括 red，blue，green，yellow，grey等，以及它们的变体如 red2，blue3，green4等等 7.1.1.12 打印幻灯片 打印幻灯片可以在浏览器中进行，目前保真度最高的浏览器可能是 Google Chrome。 此外，使用 Chrome 中 “另存为 PDF” 的功能，还可以将幻灯片保存为一份 PDF 文档。 在 R 语言终端，使用 pagedown::chrome_print() 函数也可以完成这一操作（便于自动化和批处理）。 不过需要事先安装 pagendown 软件包(R-pagedown?)。 7.1.1.13 其它功能 ioslides 幻灯片中，通用的 R Markdown 语法通常可用，包括 HTML 文档输出中的配置， 图片的属性设置，数学公式，数据库的打印，中间文件的保留，外部文档的引入等等。 7.1.2 Slidy 幻灯片 Slidy 是 HTML 幻灯片的另一个规范。 要通过 R Markdown 创建一个 Slidy 幻灯片，只需要将文档输出设为 slidy_presentation 即可。 import_example(&quot;examples/slidy-presentation.Rmd&quot;) --- title: &quot;Slidy Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: slidy_presentation: font_adjustment: +1 footer: &quot;Copyright (c) 2021, Cosname&quot; duration: 45 --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## R Markdown {.smaller} This is an R Markdown presentation. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. ## Slide with Bullets {.bigger} - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` Slidy 幻灯片的内容设置基本与 ioslides 幻灯片相似，不过其默认样式与之有异。 一份 Slidy 幻灯片大体是这样的（图 7.3）。 knitr::include_graphics(&quot;examples/slidy-presentation-screenshot.png&quot;) 图 7.3: Slidy 幻灯片 7.1.2.1 使用快捷键控制显示模式 Slidy 中也可以通过快捷键控制显示模式，不过其按键定义与 ioslides 不同。 'c'：显示幻灯片目录。Slidy 会自动生成目录，默认可以通过点击页脚左下角的 “Contents” 访问。 'f'：是否显示页脚的开关。 'a'：显示全部幻灯片的开关。 's'：缩小字体大小。 'b'：放大字体大小。 7.1.2.2 设置页脚内容 在 YAML 配置中使用 footer 可以为幻灯片设置页脚显示的内容。 --- output: slidy_presentation: footer: &quot;Copyright (c) 2021, Cosname&quot; --- 使用 duration 还可以方便的在页脚添加一个计时器（单位为分钟）。 --- output: slidy_presentation: duration: 45 --- 7.1.2.3 其它功能 Slidy 幻灯片继承了 HTML 文档中的多数功能，以及 ioslides 中的列表内容依次显示等功能。 7.1.3 Beamer 演示文稿 Beamer 是一个功能强大且灵活的 LaTeX 类，用于创建美观的演示文稿。 要从 R Markdown 创建 Beamer 演示文稿，只需要在 YAML 头文件中将输出格式设定为 beamer_presentation 即可。你可以使用一级标题 # 和二级标题 ## 新建幻灯片 （使用 --- 也可以创建一张新的没有标题的幻灯片）。例如： import_example(&quot;examples/beamer-presentation.Rmd&quot;) --- title: &quot;Beamer Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: beamer_presentation: latex_engine: xelatex header-includes: - \\usepackage{ctex} --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## Beamer 幻灯片中的中文支持 要使用中文，需要做适当的配置，包括应用 `ctex` 包（支持中文的 LaTeX 包）和使用 `xelatex` 引擎。 与 HTML 格式的幻灯片相比，这可能是制作 Beamer 演示文稿时唯一需要额外做出配置的地方了。 ## Slide with Bullets - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` Beamer 演示文稿编译后的文件是一个 PDF 文档，大概像下面这个样子（图 7.4）。 knitr::include_graphics(&quot;examples/beamer-presentation-screenshot.png&quot;) 图 7.4: Beamer 演示文稿示例 7.1.3.1 Beamer 演示文稿的中文支持 如果要生成中文的 Beamer 演示文稿，参考 6 中的设置。 7.1.3.2 Beamer 演示文稿的主题 Beamer 支持多个幻灯片主题，在 R Markdown 中使用 theme，colortheme 和 fonttheme 设定。 例如： --- output: beamer_presentation: theme: &quot;AnnArbor&quot; colortheme: &quot;dolphin&quot; fonttheme: &quot;structurebold&quot; --- 这样，上面的幻灯片就会变成下面这个样子（图 7.5）。 这个主题为标题幻灯片添加了页眉和页脚，显示作者、主题、日期和页码等信息。 import_example_result(&quot;examples/beamer-presentation-theme.Rmd&quot;) 图 7.5: 应用主题后的 Beamer 演示文稿 Beamer 支持数十个主题和颜色样式，在 这里 可以查看可用的选项。 7.1.3.3 Beamer 幻灯片的边界 slide_level 参数用来指定一张幻灯片开始的位置。默认情况下，二级标题会被识别为一张幻灯片的开始，但是你可以将它改为其它的大纲等级。 --- output: beamer_presentation: slide_level: 2 --- 7.1.3.4 其它功能 Beamer 演示文稿从 HTML 文档中继承了目录内容、图片属性、样式、数据框打印、组件、 模板、Pandoc 参数和分享等功能（参加 5），从 PDF 文档和 ioslides 演示文稿中继承了列表动画、保留 TeX 文件等功能（参见 ??, 7.1.1）。 7.1.4 PowerPoint 演示文稿 要制作 PowerPoint 演示文稿，只需要将输出格式设置为 powerpoint_presentation 即可。 这需要满足 rmarkdown 版本 ≥ v1.9，Pandoc 版本 ≥ 2.0.5 的条件5。 import_example(&quot;examples/powerpoint-presentation.Rmd&quot;) --- title: &quot;PowerPoint Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: powerpoint_presentation --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## R Markdown This is an R Markdown presentation. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. ## Slide with Bullets - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` R Markdown 生成的 PowerPoint 演示文稿大概长这个样子（图 7.6）： knitr::include_graphics(&quot;examples/powerpoint-presentation-screenshot.png&quot;) 图 7.6: PowerPoint 演示文稿 PowerPoint 演示文稿采用的幻灯片标记与 Beamer 相同，默认为 3 级标题。 使用 slide_level 可以控制新建一张幻灯片所需要的大纲等级。 此外，使用 --- 可以新建一张没有标题的幻灯片。 另外，R Markdown 中包括的图片和表格都会自动的被 放到一张新的幻灯片中。 也就是说，除了幻灯片的标题、图片/表格的标注之外，其它所有元素都不能与二者共存。 这一点与其它格式演示文稿的行为有明显不同。 一般情况下，PowerPoint 演示文稿中的图片会被自动缩放到适合幻灯片的大小。 如果自动缩放无效，那么对于静态图片可以使用 width 和 height 来分别设置， 例如：![caption](foo.png){width=40%}。 对于 R 语言生成的动态图形，则可以使用代码块的参数 fig.width 和 fig.height 来定义宽和高。 PowerPoint 幻灯片中可以使用的 Markdown 标记（参见 ??）包括粗体、斜体，脚注，列表，LaTeX 数学表达式， 图片，表格等。 7.1.4.1 两栏布局 正如 Beamer 演示文稿的高级应用需要借助于 LaTeX 语法一样， PowerPoint 演示文稿的高级应用需要借助于对 Pandoc 的深入了解。 使用 Pandoc 的语法，可以设置一个多栏的布局（请参见 Pandoc 的用户手册）： :::::: {.columns} ::: {.column} Content of the left column. ::: ::: {.column} Content of the right column. ::: :::::: 7.1.4.2 自定义模板 PowerPoint 演示文稿的模板可以用 reference_doc 来设置。 模板中的样式将会被应用到 R Markdown 生成的 PowerPoint 演示文稿中。 --- title: &quot;使用你喜欢的 PowerPoint 模板&quot; output: powerpoint_presentation: reference_doc: my-styles.pptx --- 7.1.4.3 其它功能 PowerPoint 演示文稿从 HTML 文档中继承了目录内容、图片属性、样式、数据框打印、组件、 模板、Pandoc 参数和分享等功能（参加 5）。 目前并不支持列表中各个项目的播放效果。 7.2 Xaringan 幻灯片 虽然 R Markdown 提供的基础幻灯片已经能够实现了基本的幻灯片功能，而且没有额外的学习成本， 但是，善于制作精良幻灯片的“忍者”通常使用一个额外的包来创建幻灯片，这个包的名字叫做 xaringan。 xaringan 这个名字来源于火影忍者中的写轮眼 “Sharingan” （图 7.7）6。写轮眼有两大能力： 洞察眼 催眠眼 其实做演示就是将自己的洞见传递给听众；好的演讲通常有催眠效果，因为它可以深度震撼人心7。 knitr::include_graphics(&quot;images/xaringan-hex.png&quot;) 图 7.7: 幻灯忍者：写轮眼 与其它工具相比，xaringan 创建的幻灯片样式更加精美，功能更加丰富，且具有高度的可定制性（图 7.8）。 knitr::include_graphics(&quot;images/xaringan-scrennshot.png&quot;) 图 7.8: xaringan 幻灯片的实例 要创建“写轮眼”幻灯片，需要先安装 xaringan 包(Xie 2021b)）。 if (!requireNamespace(&quot;xaringan&quot;)) install.packages(&quot;xaringan&quot;) 安装完成之后，在 RStudio 中新建文件 R Markdown 文件时，在左侧选择 “From Template”即可。 ## ## tikzDevice: No appropriate LaTeX compiler could be found. ## Access to LaTeX is required in order for the TikZ device ## to produce output. ## ## The following places were tested for a valid LaTeX compiler: ## ## the global option: tikzLatex ## the environment variable: R_LATEXCMD ## the environment variable: R_PDFLATEXCMD ## the global option: latexcmd ## the PATH using the command: pdflatex ## the PATH using the command: latex ## the PATH using the command: /usr/texbin/pdflatex ## ## If you have a working LaTeX compiler, try one of the ## following solutions: ## ## Set the path to your compiler as the value of either latexcmd or ## tikzLatex in .Rprofile using options(). ## ## Set the path to your compiler as the value of either R_LATEXCMD or ## R_PDFLATEXCMD in .Renviron. ## ## Ensure the folder containing your compiler is included in PATH. 在这里，左边图片的大小要合适，才能把列表项挤到右边去。↩︎ 分别使用 packageVersion('rmarkdown') 和 rmarkdown::pandoc_version() 来查看 rmarkdown 和 Pandoc 的版本。↩︎ 把 “Sh” 换成了 “x” 是为了更易拼读。↩︎ 糟糕的演讲也可以催眠听众，但显然这两种催眠完全不同。↩︎ "],["table.html", "第 8 章 表格操作 8.1 表格生成函数 knitr::kable() 8.2 kableExtra 包 8.3 其它生成表格的包", " 第 8 章 表格操作 在日常报告中，表格是我们展示结果的主要方式之一。为了满足你的特定需求，你可能经常需要调整各个表格的外观。在本章中，我们将介绍如何个性化制作表格。本章主要目的如下: 展现表格生成函数 knitr::kable() 的所有特征； 使用 kableExtra 包 (Zhu 2020) 来展现更高级的个性化制作方法； 提供其它生成表格的R包。 8.1 表格生成函数 knitr::kable() 在 knitr 中，函数 kable() 是一个非常简单的表格生成器，并且设计简单。它仅为严格的“矩形数据”（如矩阵和数据框）生成表格，不能自由地设计单元格或合并单元格。然而，这个函数有大量的参数供你自定义表格的外观: kable(x, format, digits = getOption(&quot;digits&quot;), row.names = NA, col.names = NA, align, caption = NULL, label = NULL, format.args = list(), escape = TRUE, ...) 8.1.1 已支持的表的格式 在大多数情况下，如果你只需要数据对象 x 的一个简单表格，knitr::kable(x) 就足够了，format 参数会根据 knitr 源文档自动设置。它可能的取值是 pipe （列与列之间由短的竖线分隔的表），simple （Pandoc 的简单表格），latex （LaTex 表格），html （HTML 表格），和 rst （reStructuredText 表格）。对于 R Markdown 文档，kable() 默认使用’ pipe 格式的表格，如下所示: knitr::kable(head(mtcars[, 1:4]), &#39;pipe&#39;) | | mpg| cyl| disp| hp| |:-----------------|----:|---:|----:|---:| |Mazda RX4 | 21.0| 6| 160| 110| |Mazda RX4 Wag | 21.0| 6| 160| 110| |Datsun 710 | 22.8| 4| 108| 93| |Hornet 4 Drive | 21.4| 6| 258| 110| |Hornet Sportabout | 18.7| 8| 360| 175| |Valiant | 18.1| 6| 225| 105| 你也可以生成基于 Pandoc 的简单表格，或 HMTL、LaTex以及 reStructuredText 格式的表格： knitr::kable(head(mtcars[, 1:4]), &#39;simple&#39;) mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 Datsun 710 22.8 4 108 93 Hornet 4 Drive 21.4 6 258 110 Hornet Sportabout 18.7 8 360 175 Valiant 18.1 6 225 105 knitr::kable(mtcars[1:2, 1:2], &#39;html&#39;) &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style=&quot;text-align:left;&quot;&gt; &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; mpg &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; cyl &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 Wag &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; knitr::kable(head(mtcars[, 1:4]), &#39;latex&#39;) \\begin{tabular}{l|r|r|r|r} \\hline &amp; mpg &amp; cyl &amp; disp &amp; hp\\\\ \\hline Mazda RX4 &amp; 21.0 &amp; 6 &amp; 160 &amp; 110\\\\ \\hline Mazda RX4 Wag &amp; 21.0 &amp; 6 &amp; 160 &amp; 110\\\\ \\hline Datsun 710 &amp; 22.8 &amp; 4 &amp; 108 &amp; 93\\\\ \\hline Hornet 4 Drive &amp; 21.4 &amp; 6 &amp; 258 &amp; 110\\\\ \\hline Hornet Sportabout &amp; 18.7 &amp; 8 &amp; 360 &amp; 175\\\\ \\hline Valiant &amp; 18.1 &amp; 6 &amp; 225 &amp; 105\\\\ \\hline \\end{tabular} knitr::kable(head(mtcars[, 1:4]), &#39;rst&#39;) ================= ==== === ==== === \\ mpg cyl disp hp ================= ==== === ==== === Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 Datsun 710 22.8 4 108 93 Hornet 4 Drive 21.4 6 258 110 Hornet Sportabout 18.7 8 360 175 Valiant 18.1 6 225 105 ================= ==== === ==== === 需要注意的是，只有 pipe 和 simple 格式是可移植的，也就是说，它们适用于任何输出文档的格式，而其他格式则只适用于特定的输出格式，例如，format = 'latex' 只适用于 LaTex 输出文档。使用特定的表格格式可以带给你更多的自主控制能力，但代价是牺牲了可移植性。 如果你只需要一种非默认的表格格式，你可以直接设置全局的 R 选项 knitr.table.format，例如, options(knitr.table.format = &#39;latex&#39;) 这一选项也可以是一个返回格式字符串或 NULL 的函数，在 NULL 的情况下，knitr 将自动决定适当的格式。例如，我们只能在输出格式为 LaTeX 时使用 latex 格式: options(knitr.table.format = function() { if (knitr::is_latex_output()) &#39;latex&#39; else &#39;pipe&#39; }) 8.1.2 修改列名 数据框中我们定义的列的名称可能与我们想要显示给读者的内容不同，在 R 中，数据的列名通常不使用空格来分隔单词，而是使用点、下划线以及大小写来进行分隔。而当我们在制作表格时，这样子的变量名会显得有些不自然。在这种情况下，我们可以使用 col.names 参数将列名替换为一个包含新名称的向量。例如，我们可以在 iris 数据的列名中用空格代替点: iris2 = head(iris) knitr::kable(iris2, col.names = gsub(&#39;[.]&#39;, &#39; &#39;, names(iris))) Sepal Length Sepal Width Petal Length Petal Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa col.names 参数可以接受任意字符向量（不一定是通过 gsub() 等函数修改的列名），只要向量的长度等于数据对象的列数即可，例如： knitr::kable( iris, col.names = c(&#39;We&#39;, &#39;Need&#39;, &#39;Five&#39;, &#39;Names&#39;, &#39;Here&#39;) ) 8.1.3 指定列的对齐方式 要改变表格中列的对齐方式，可以使用由字符 l （左对齐）、c （居中）以及 r （右对齐）组成的值向量或一个多字符的字符串来进行对齐，例如可以将 kable(..., align = c('c', 'l')) 缩写为 kable(..., align = 'cl') 。在默认情况下，数字列是右对齐的，其他列是左对齐的。下面是一个例子: # 左对齐，居中，居中，右对齐，右对齐 knitr::kable(iris2, align = &#39;lccrr&#39;) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 8.1.4 添加表格标题 你可以通过 caption 参数来给表格添加一个标题，如表8.1： knitr::kable(iris2, caption = &#39;一个简单的标题&#39;) 表 8.1: 一个简单的标题 Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 正如我们在本书??节所提到的那样，当一个表格有标题并且以 bookdown 来输出格式时，它可以被交叉引用。 8.1.5 调整数字格式 你可以通过digits参数（会被传递给round()函数）来设置最大的小数位数，以及通过format.args（会被传递给R中的format()函数）来设置其他格式化参数。首先，我们展示了几个简单的round()和format()的例子，从而帮助你在之后的kable()中理解这些参数是如何工作的: round(1.234567, 0) ## [1] 1 round(1.234567, digits = 1) ## [1] 1.2 round(1.234567, digits = 3) ## [1] 1.235 format(1000, scientific = TRUE) ## [1] &quot;1e+03&quot; format(10000.123, big.mark = &#39;,&#39;) ## [1] &quot;10,000.12&quot; 然后我们将数字四舍五入并格式化成表格： d = cbind(X1 = runif(3), X2 = 10^c(3, 5, 7), X3 = rnorm(3, 0, 1000)) # 保留最多四位小数 knitr::kable(d, digits = 4) X1 X2 X3 0.7221 1e+03 819.2824 0.2575 1e+05 -386.7071 0.5167 1e+07 70.5297 # 每列分别设置 knitr::kable(d, digits = c(5, 0, 2)) X1 X2 X3 0.72213 1e+03 819.28 0.25746 1e+05 -386.71 0.51673 1e+07 70.53 # 不使用科学计数法 knitr::kable(d, digits = 3, format.args = list(scientific = FALSE)) X1 X2 X3 0.722 1000 819.282 0.257 100000 -386.707 0.517 10000000 70.530 # 给 big numbers 添加逗号 knitr::kable(d, digits = 3, format.args = list(big.mark = &#39;,&#39;, scientific = FALSE)) X1 X2 X3 0.722 1,000 819.282 0.257 100,000 -386.707 0.517 10,000,000 70.530 8.1.6 显示缺失值 在默认情况下，缺失值（如NA）在表格中显示为字符串NA，你可以使用其他的值来替换它们，或者通过使用全局R选项 knitr.kable.NA来选择不显示任何东西（例如使NA对应的单元格为空），。例如，我们将在下面第二个表中的NA单元格设为空，然后在第三个表中显示**； d[rbind(c(1, 1), c(2, 3), c(3, 2))] = NA knitr::kable(d) # 默认显示 NA X1 X2 X3 NA 1e+03 819.28238 0.2574640 1e+05 NA 0.5167251 NA 70.52973 # 用空值代替 NA opts = options(knitr.kable.NA = &#39;&#39;) knitr::kable(d) X1 X2 X3 1e+03 819.28238 0.2574640 1e+05 0.5167251 70.52973 # 用指定字符（**） 代替 NA options(knitr.kable.NA = &#39;**&#39;) knitr::kable(d) X1 X2 X3 ** 1e+03 819.28238 0.2574640 1e+05 ** 0.5167251 ** 70.52973 options(opts) # 恢复全局 R 选项 8.1.7 特殊字符的转义 对于HTML或者LaTex，对应的编程语言之中包含了一些特殊的字符。为了使结果能够正常输出，kable()将默认通过参数escape = TRUE来转义这些特殊字符，这意味着所有的字符将逐字生成，特殊字符将失去其特殊含义。例如对于HTML格式的表格，&gt;将被替换为&amp;gt;；而对于LaTex格式的表格，_将转义为\\_。如果你接触过这些字符，并且知道如何正确使用它们，那么可以通过escape = FALSE来禁用这个参数。在下面的第二个表中，我们介绍了一些包含特殊字符（$、\\以及_）的LaTex数学表达式： m = lm(dist ~ speed, data = cars) d = coef(summary(m)) knitr::kable(d) Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -17.579095 6.7584402 -2.601058 0.0123188 speed 3.932409 0.4155128 9.463990 0.0000000 # 在行名和列名中添加数学表达式 rownames(d) = c(&#39;$\\\\beta_0$&#39;, &#39;$\\\\beta_1$&#39;) colnames(d)[4] = &#39;$P(T &gt; |t|)$&#39; knitr::kable(d, escape = FALSE) Estimate Std. Error t value \\(P(T &gt; &amp;#124;t&amp;#124;)\\) \\(\\beta_0\\) -17.579095 6.7584402 -2.601058 0.0123188 \\(\\beta_1\\) 3.932409 0.4155128 9.463990 0.0000000 如果没有escape = FALSE，特殊字符将被转义或替换。例如，$会被转义为\\$、_被转义为\\_以及\\ ’被替换为\\textbackslash{}: knitr::kable(d, format = &#39;latex&#39;, escape = TRUE) \\begin{tabular}{l|r|r|r|r} \\hline &amp; Estimate &amp; Std. Error &amp; t value &amp; \\$P(T &gt; |t|)\\$\\\\ \\hline \\$\\textbackslash{}beta\\_0\\$ &amp; -17.579095 &amp; 6.7584402 &amp; -2.601058 &amp; 0.0123188\\\\ \\hline \\$\\textbackslash{}beta\\_1\\$ &amp; 3.932409 &amp; 0.4155128 &amp; 9.463990 &amp; 0.0000000\\\\ \\hline \\end{tabular} 其他LaTex中常见的特殊字符包括#、%、&amp;、{以及 }；HTML中常见的特殊字符包括&amp;、&lt;、 &gt;以及\"。在生成带有escape = FALSE的表格时，需要格外小心并确保正确地使用了特殊字符。一个常见的错误是在使用escape = FALSE时，在LaTeX表格的列名或标题中包含%或_等字符，而没有意识到它们是特殊的字符。 如果你不确定如何正确地转义特殊字符，在knitr中有两个内部辅助函数。下面是一些例子： knitr:::escape_latex(c(&#39;100%&#39;, &#39;# a comment&#39;, &#39;column_name&#39;)) ## [1] &quot;100\\\\%&quot; &quot;\\\\# a comment&quot; &quot;column\\\\_name&quot; knitr:::escape_html(c(&#39;&lt;address&gt;&#39;, &#39;x = &quot;character&quot;&#39;, &#39;a &amp; b&#39;)) ## [1] &quot;&amp;lt;address&amp;gt;&quot; &quot;x = &amp;quot;character&amp;quot;&quot; ## [3] &quot;a &amp;amp; b&quot; 8.1.8 多张表格并排 你可以通过将数据框或矩阵的列表传递给kable()来并排生成很多张表。例如，表8.2 包含以下代码生成的两个表: d1 &lt;- head(cars, 3) d2 &lt;- head(mtcars[, 1:3], 5) knitr::kable( list(d1, d2), caption = &#39;两张表并排放置&#39;, booktabs = TRUE, valign = &#39;t&#39; ) 表 8.2: 两张表并排放置 speed dist 4 2 4 10 7 4 mpg cyl disp Mazda RX4 21.0 6 160 Mazda RX4 Wag 21.0 6 160 Datsun 710 22.8 4 108 Hornet 4 Drive 21.4 6 258 Hornet Sportabout 18.7 8 360 需要注意的是，此功能仅适用于HTML和PDF格式的输出。 如果你想在将每个表并排放置时能够分别自定义它们，你可以使用kables()函数（kable()的复数形式），并将一个对象为kable()的列表传递给它。例如，在表 8.3 中，我们更改左表中的列名，并将右表中的小数点位数设置为零： # 数据对象 d1 和 d2 由之前的代码块生成 knitr::kables( list( # 第一个 kable()：修改列名 knitr::kable( d1, col.names = c(&#39;SPEED&#39;, &#39;DISTANCE&#39;), valign = &#39;t&#39; ), # 第二个 kable()：设置 digits 选项 knitr::kable(d2, digits = 0, valign = &#39;t&#39;) ), caption = &#39;由 knitr::kables() 生成的两张表&#39; ) 表 8.3: 由 knitr::kables() 生成的两张表 SPEED DISTANCE 4 2 4 10 7 4 mpg cyl disp Mazda RX4 21 6 160 Mazda RX4 Wag 21 6 160 Datsun 710 23 4 108 Hornet 4 Drive 21 6 258 Hornet Sportabout 19 8 360 8.1.9 利用for循环生成多个表 (*) 对于kable()，有一个常见的错误认识是它不能在for循环中工作。这个问题并不特定于kable()，同时也存在于许多其他的R包中。其背后原因有点复杂，如果你对技术细节感兴趣，可以在博文“The Ghost Printer behind Top-level R Expressions.” 中进行进一步的了解。 你可能期望下面的代码块可以生成三个表，但事实上它并不会： ```{r} for (i in 1:3) { knitr::kable(head(iris)) } ``` 你必须显式打印kable()结果，并应用chunk选项results = 'asis'，例如： ```{r, results=&#39;asis&#39;} for (i in 1:3) { print(knitr::kable(head(iris))) } ``` 通常情况下，当你从for循环中输出结果时，我们建议你添加一些换行符（\\n）或HTML注释（&lt;!-- --&gt;），以便清晰地分隔所有输出的元素，例如: ```{r, results=&#39;asis&#39;} for (i in 1:3) { print(knitr::kable(head(iris), caption = &#39;A caption.&#39;)) cat(&#39;\\n\\n&lt;!-- --&gt;\\n\\n&#39;) } ``` 如果没有这些分隔符，Pandoc可能无法检测到单个元素。例如，当一个图片之后面紧跟着一个表格时，这个表格不会被识别： ![](logo.png) mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 但如果像这样有一个清晰的分隔（注意，我们在图像下面添加了一个空行），它将变成： ![](logo.png) mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 或者 ![](logo.png) &lt;!-- --&gt; mpg cyl disp hp ------------------ ----- ---- ----- ---- Mazda RX4 21.0 6 160 110 Mazda RX4 Wag 21.0 6 160 110 8.1.10 自定义 LaTex 表格 (*) 如果你只需要LaTex的输出格式，则可以在kable()中使用一些额外的选项。注意在其他类型的输出中（如HTML），这些选项将被忽略。除非你已经设置了全局的表格格式选项（见本书8.1.1节），否则必须像本节的例子那样使用kable()的format参数，例如： knitr::kable(iris2, format = &#39;latex&#39;, booktabs = TRUE) 当你给一个表格分配一个标题时（见本书8.1.4节）， kable()将使用table环境来纳入这个表，即： \\begin{table} % 表格 (通常为 tabular 环境) \\end{table} 你可以通过table.envir参数来改变这个环境，即： knitr::kable(cars[1:2, ], format = &#39;latex&#39;, table.envir = &#39;figure&#39;) \\begin{figure} \\begin{tabular}{r|r} \\hline speed &amp; dist\\\\ \\hline 4 &amp; 2\\\\ \\hline 4 &amp; 10\\\\ \\hline \\end{tabular} \\end{figure} 表格的位置由参数position来控制。例如，我们可以通过position = \"!b\"来强制将表格固定到页面的底部： knitr::kable(cars[1:2, ], format = &#39;latex&#39;, table.envir = &#39;table&#39;, position = &#39;!b&#39;) \\begin{table}[!b] \\begin{tabular}{r|r} \\hline speed &amp; dist\\\\ \\hline 4 &amp; 2\\\\ \\hline 4 &amp; 10\\\\ \\hline \\end{tabular} \\end{table} 当一个表格有一个标题时，你也可以通过caption.short参数给它分配一个短的标题，例如： knitr::kable(iris2, caption = &#39;一个很长很长的标题！&#39;, caption.short = &#39;短标题&#39;) 短标题进入LaTeX中的\\caption[]{}命令的方括号中，经常在PDF输出文档的表格目录中使用（如果不提供短标题，那里则会显示完整的标题）。 如果你熟悉用于生成可供发布的表格的LaTeX包booktabs{LaTeX package!booktabs}，您可以设置booktabs = TRUE，例如： iris3 = head(iris, 10) knitr::kable(iris3, format = &#39;latex&#39;, booktabs = TRUE) \\begin{tabular}{rrrrl} \\toprule{} Sepal.Length &amp; Sepal.Width &amp; Petal.Length &amp; Petal.Width &amp; Species\\\\ \\midrule{} 5.1 &amp; 3.5 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.9 &amp; 3.0 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.7 &amp; 3.2 &amp; 1.3 &amp; 0.2 &amp; setosa\\\\ 4.6 &amp; 3.1 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 5.0 &amp; 3.6 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ \\addlinespace 5.4 &amp; 3.9 &amp; 1.7 &amp; 0.4 &amp; setosa\\\\ 4.6 &amp; 3.4 &amp; 1.4 &amp; 0.3 &amp; setosa\\\\ 5.0 &amp; 3.4 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 4.4 &amp; 2.9 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.9 &amp; 3.1 &amp; 1.5 &amp; 0.1 &amp; setosa\\\\ \\bottomrule{} \\end{tabular} 需要注意的是，当你在R Markdown文档中需要额外的LaTeX包时（如booktabs），你必须在YAML中声明这些包（请参阅??一节了解如何声明）。 参数booktabs取TRUE或FALSE(默认值)时，表的外观是不同的。对于booktabs = FALSE： 表的列由垂直线分隔。你可以通过vline参数来删除垂直线，例如knitr::kable(iris, vline = \"\") （默认值是vline = \"|\"）。你可以将这个选项设置为一个全局的R选项，这样你就不需要为每个表设置它，例如，options(knitr.table.vline = \"\")。 水平线可以通过参数toprule、midrule、linesep以及 bottomrule来定义，它们的默认值都是\\hline。 对于 booktabs = TRUE： 表格中没有垂直线，但可以通过vline参数来添加。 表格的只有标题和底部行有水平线。默认参数值是toprule = \"\\\\toprule\"、midrule = \"\\\\midrule\"以及bottomrule = \"\\\\bottomrule\"。默认情况下，每5行加一个行间距（\\addlinespace），这是由参数linesep控制的，默认值为c(\"\", \"\", \"\", \"\", \"\\\\addlinespace\")。如果你想每3行加一个\\addlinespace，你可以这样做: knitr::kable(iris3, format = &#39;latex&#39;, linesep = c(&#39;&#39;, &#39;&#39;, &#39;\\\\addlinespace&#39;), booktabs = TRUE) \\begin{tabular}{rrrrl} \\toprule{} Sepal.Length &amp; Sepal.Width &amp; Petal.Length &amp; Petal.Width &amp; Species\\\\ \\midrule{} 5.1 &amp; 3.5 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.9 &amp; 3.0 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 4.7 &amp; 3.2 &amp; 1.3 &amp; 0.2 &amp; setosa\\\\ \\addlinespace 4.6 &amp; 3.1 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 5.0 &amp; 3.6 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ 5.4 &amp; 3.9 &amp; 1.7 &amp; 0.4 &amp; setosa\\\\ \\addlinespace 4.6 &amp; 3.4 &amp; 1.4 &amp; 0.3 &amp; setosa\\\\ 5.0 &amp; 3.4 &amp; 1.5 &amp; 0.2 &amp; setosa\\\\ 4.4 &amp; 2.9 &amp; 1.4 &amp; 0.2 &amp; setosa\\\\ \\addlinespace 4.9 &amp; 3.1 &amp; 1.5 &amp; 0.1 &amp; setosa\\\\ \\bottomrule{} \\end{tabular} 如果你想删除所有的行间距，你可以使用linesep = ''。 有的时候，表可能比一页还长。在本例中，你可以使用参数longtable = TRUE，该参数使用LaTeX包longtable将表跨到多个页面。 当表格被包含在table环境中时（例如，当表有标题时），表格默认居中对齐。如果你不想让表格居中，可以使用参数centering = FALSE。 8.1.11 自定义 HTML 表格 (*) 如果你想自定义通过knitr::kable(format = \"html\")生成的表，除了前面提到的常见参数外，只有一个额外的参数需要注意：table.attr。这个参数允许你向&lt;table&gt;标签添加任意属性。例如： knitr::kable(mtcars[1:2, 1:2], table.attr = &#39;class=&quot;striped&quot;&#39;, format = &quot;html&quot;) &lt;table class=&quot;striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style=&quot;text-align:left;&quot;&gt; &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; mpg &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; cyl &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; Mazda RX4 Wag &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 21 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 6 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 我们向表格中添加了一个类striped。然而，类名不足以改变表的外观。你必须定义CSS类的规则。例如，要制作奇数行和偶数行有不同颜色的条纹表，您可以为偶数行或奇数行添加浅灰色背景: .striped tr:nth-child(even) { background: #eee; } 上面的CSS规则意味着所有striped类的元素的子元素，且具有偶数行号（:nth-child(even)）的行（即&lt;tr&gt;标签），将它们的背景颜色设置为#eee。 使用一点CSS可以使一个普通的HTML表看起来好看很多。图 8.1是一个HTML表格的截图，其中应用了以下CSS规则： table { margin: auto; border-top: 1px solid #666; border-bottom: 1px solid #666; } table thead th { border-bottom: 1px solid #ddd; } th, td { padding: 5px; } thead, tfoot, tr:nth-child(even) { background: #eee; } 图 8.1: A striped table created with HTML and CSS. 8.2 kableExtra 包 kableExtra 包 (Zhu 2020) 设计的目的为扩展knitr::kable()生成表格的基本功能（见8.1节）。由于knitr::kable()的设计很简单，就像很多其他的R包一样，它肯定有很多缺失的功能，而kableExtra完美地填补了空白。最令人惊讶的是，kableExtra的大多数表格的特性都适用于HTML和PDF格式，例如，绘制如图8.1的条纹表。 一般情况下，kableExtra 包可以通过CRAN安装，你也可以尝试GitHub上的开发版本 (https://github.com/haozhu233/kableExtra): # install from CRAN install.packages(&quot;kableExtra&quot;) # install the development version remotes::install_github(&quot;haozhu233/kableExtra&quot;) https://haozhu233.github.io/kableExtra/ 提供了大量的文档，介绍了很多关于如何自定义kable()的HTML或LaTex输出结果的例子。本节只提供几个示例，如有兴趣我们建议您详细阅读该文档。 kableExtra包支持使用管道操作符%&gt;%，你可以将kable()的输出结果连到kableExtra的样式函数上，例如 library(knitr) library(kableExtra) kable(iris) %&gt;% kable_styling(latex_options = &quot;striped&quot;) 8.2.1 设定字体尺寸 kableExtra包中的kable_styling()函数允许你对整个表进行样式化。例如，你可以指定页面上表格的对齐方式、表格的宽度和字体大小。下面是一个使用小字体的例子: kable(head(iris, 5), booktabs = TRUE) %&gt;% kable_styling(font_size = 8) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 8.2.2 特定的行或列的样式 函数row_spec()和column_spec()可分别用于样式化单独的行和列。在下面的示例中，我们将第一行文字加粗并设为斜体，将第二行和第三行添加黑色背景，同时更改字体颜色为白色，给第四行文字加下划线并更改其字体，旋转第五行文字，并给第五列加删除线： kable(head(iris, 5), align = &#39;c&#39;, booktabs = TRUE) %&gt;% row_spec(1, bold = TRUE, italic = TRUE) %&gt;% row_spec(2:3, color = &#39;white&#39;, background = &#39;black&#39;) %&gt;% row_spec(4, underline = TRUE, monospace = TRUE) %&gt;% row_spec(5, angle = 45) %&gt;% column_spec(5, strikeout = TRUE) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 类似地，你可以使用cell_spec()函数来给单个单元格设定样式。 8.2.3 给行或列分组 行和列可以分别通过函数pack_rows()和add_header_above()来进行分组。你也可以通过collapse_rows()来折叠行，这样一个单元格可以跨越多个行。下面是一个例子，展示了一个给标题列分组后的表格： iris2 &lt;- iris[1:5, c(1, 3, 2, 4, 5)] names(iris2) &lt;- gsub(&#39;[.].+&#39;, &#39;&#39;, names(iris2)) kable(iris2, booktabs = TRUE) %&gt;% add_header_above(c(&quot;Length&quot; = 2, &quot;Width&quot; = 2, &quot; &quot; = 1)) %&gt;% add_header_above(c(&quot;Measurements&quot; = 4, &quot;More attributes&quot; = 1)) Measurements More attributes Length Width Sepal Petal Sepal Petal Species 5.1 1.4 3.5 0.2 setosa 4.9 1.4 3.0 0.2 setosa 4.7 1.3 3.2 0.2 setosa 4.6 1.5 3.1 0.2 setosa 5.0 1.4 3.6 0.2 setosa 对于add_header_above()中的命名向量，其名称是显示在表头中的文本，向量的整数值表示一个名称应该跨越多少列，例如，\"Length\" = 2表示Length应该跨越两列。 下面是pack_rows()的示例，其中index参数的含义类似于我们之前解释过的add_header_above()参数。 iris3 &lt;- iris[c(1:2, 51:54, 101:103), ] kable(iris3[, 1:4], booktabs = TRUE) %&gt;% pack_rows( index = c(&quot;setosa&quot; = 2, &quot;versicolor&quot; = 4, &quot;virginica&quot; = 3) ) Sepal.Length Sepal.Width Petal.Length Petal.Width setosa 1 5.1 3.5 1.4 0.2 2 4.9 3.0 1.4 0.2 versicolor 51 7.0 3.2 4.7 1.4 52 6.4 3.2 4.5 1.5 53 6.9 3.1 4.9 1.5 54 5.5 2.3 4.0 1.3 virginica 101 6.3 3.3 6.0 2.5 102 5.8 2.7 5.1 1.9 103 7.1 3.0 5.9 2.1 8.2.4 按比例缩小LaTex中的表格 有一些特性是HTML或LaTeX输出格式特有的。例如，横向打印格式只在LaTeX中有意义，所以kableExtra中的’landscape()函数只对LaTeX格式的输出有效。下面的例子中，我们将表格按比例缩小以适应页面的宽度（否则该表格会太宽）: tab &lt;- kable(tail(mtcars, 5), booktabs = TRUE) tab # original table (too wide) mpg cyl disp hp drat wt qsec vs am gear carb Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 tab %&gt;% kable_styling(latex_options = &quot;scale_down&quot;) mpg cyl disp hp drat wt qsec vs am gear carb Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 Ford Pantera L 15.8 8 351.0 264 4.22 3.170 14.5 0 1 5 4 Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.5 0 1 5 6 Maserati Bora 15.0 8 301.0 335 3.54 3.570 14.6 0 1 5 8 Volvo 142E 21.4 4 121.0 109 4.11 2.780 18.6 1 1 4 2 注意如果你在浏览HTML版本的话，上面两个表格是没有差异的。 8.3 其它生成表格的包 还有很多其他的R包可以用来生成表格。我们引入kable() （见8.1节）和kableExtra （见8.2节）的主要原因不是它们比其他包更好，而是因为我们只熟悉它们。接下来将列出一些我们知道但不太熟悉的软件包。你可以自己看看，然后去决定哪一个最适合你。 flextable (R-flextable?) 和 huxtable (R-huxtable?)：如果您正在寻找一个支持最多种表格输出格式的包，flextable和huxtable可能是两个最好的选择。它们都支持HTML、LaTeX以及Office格式，并且包含最常见的表格特性（例如条件格式化）。更多关于flextable的信息可参见：https://davidgohel.github.io/flextable/，huxtable的说明文档则在：https://hughjonesd.github.io/huxtable/。 gt (R-gt?)：这个R包允许你将表格的不同部分组合在一起，例如表头（标题和副标题）、列标签、表格主体、行组标签以及表格的脚注，从而组成一个完整的表格，其中有些部分是可选择性添加的。你还可以格式化数字，并为单元格添加背景阴影。目前gt主要支持HTML输出。8更多关于gt的信息可参见：https://gt.rstudio.com。 formattable (R-formattable?)：这个R包提供了一些格式化数字的工具函数（如percent()和accounting()），以及对列进行样式化的函数（如格式化文本，用背景阴影或颜色条注释数字，或在单元格中添加图标等等）。和gt相同，formattable包也主要支持HTML格式。更多信息可参见GitHub项目：https://github.com/renkun-ken/formattable/。 DT (R-DT?)：本书的作者之一（谢益辉）为这个包的作者，但我们没有单独介绍它，因为它只支持HTML格式。DT构建在JavaScript库DataTables之上，它可以将静态表转换为HTML页面上的交互式表。你可以对表进行排序、搜索和分页。DT还支持格式化单元格，与Shiny一起构建交互式应用程序，并包含了大量的DataTables扩展（例如，你可以将表格导出到Excel，或交互式重新排列表格的列）。更多信息可参见：https://github.com/rstudio/DT/。 reactable (R-reactable?)：与DT类似，这个包也基于JavaScript库创建交互式表。坦率地说，在我们看来，它在某些方面比DT更好（比如行分组和聚合操作，以及嵌入HTML小部件）。如果2015年有了reactable，我（谢益辉）可能就不会开发DT了。也就是说，reactable并不包含DT全部的特性，所以你可以阅读它的文档，看看哪个更适合你：https://glin.github.io/reactable/。 rhandsontable(R-rhandsontable?)：这个包也类似于DT，并且和Excel比较像（例如，你可以直接在表中编辑数据），更多信息可参见：https://jrowen.github.io/rhandsontable/。 pixiedust (R-pixiedust?)：这个包通过broom包(R-broom?)来为为模型结果（如线性模型）创建表格，它支持Markdown、HTML以及LaTeX输出格式。更多信息可参见：https://github.com/nutterb/pixiedust/。 stargazer (R-stargazer?)：格式化回归模型和汇总统计表。更多信息可参见：https://cran.r-project.org/package=stargazer/。 xtable (Dahl et al. 2019)；这个包可能是最早的创建表格的包，其第一次发布是在2000年。它同时支持LaTeX和HTML格式。该软件包可在CRAN上访问：https://cran.r-project.org/package=xtable/。 还有一些其它生成表格的包，我们不打算再进一步介绍，只是在这里列出它们，以供感兴趣者参考：tables (R-tables?)、pander (R-pander?)、tangram (R-tangram?)、ztable (R-ztable?)以及condformat (R-condformat?)。 如果你需要支持其他输出格式，如LaTeX和Word，gtsummary包(R-gtsummary?)已经做了一些基于gt的扩展：https://github.com/ddsjoberg/gtsummary.↩︎ "],["chunk-options.html", "第 9 章 块选项 9.1 在块选项中使用变量 9.2 如何在遇到 error 的时候继续编译 9.3 同一张图的多种图像输出格式 9.4 缓存耗时的代码块 9.5 为多种输出格式缓存代码块 9.6 缓存大型的对象 9.7 隐藏源代码、message、warning、文本输出或图像输出 9.8 隐藏代码块的所有输出 9.9 将文本输出压缩到源代码块中 9.10 重新格式化源代码 9.11 将输出文本作为原始的Markdown的内容 (*) 9.12 删除文本输出中的前导符号 9.13 为文本输出块添加属性 (*) 9.14 图像的后期加工 (*) 9.15 高质量的图像 (*) 9.16 带有低级绘图功能的逐步绘图 (*) 9.17 在代码块中自定义对象的打印格式 (*) 9.18 选项钩子 (*)", " 第 9 章 块选项 正如图??所展示的那样，R包knitr在R Markdown中起着关键的作用。在本章和接下来的两章中，我们将展示一些与knitr相关的编程技巧。 事实上，R Markdown的代码块中，有超过50个选项可以用来微调knitr处理基于R代码块的方式，选项的完整列表请参阅在线文档https://yihui.org/knitr/options/。 在接下来的几节中，我们只展示了将块选项应用到单个代码块的示例。然而需要注意的是，任何块选项也可以进行全局设置，应用于整个文档，不必在每个代码块中重复这些选项。如果要设置全局的块选项，需要在代码块（通常为文档中的第一个代码块）中调用knitr::opts_chunk$set()，例如： ```{r, include=FALSE} knitr::opts_chunk$set( comment = &quot;#&gt;&quot;, echo = FALSE, fig.width = 6 ) ``` 9.1 在块选项中使用变量 通常情况下，块选项中会使用常数（如：fig.width = 6），但实际上可以使用任意的R表达式，无论简单或复杂。一个特殊的情况是变量传递给一个块选项（注意变量本身也是一个R表达式）。例如，你可以在文档开始的部分定义图像宽度，然后在其他代码块中使用它，从而更方便地更改图像宽度： ```{r} my_width &lt;- 7 ``` ```{r, fig.width=my_width} plot(cars) ``` 块选项中也可以使用if-else语句，例如： ```{r} fig_small &lt;- FALSE # change to TRUE for larger figures width_small &lt;- 4 width_large &lt;- 8 ``` ```{r, fig.width=if (fig_small) width_small else width_large} plot(cars) ``` 不仅如此，我们还可以只在所需要的包可使用时才运行一个代码块： ```{r, eval=require(&#39;leaflet&#39;)} library(leaflet) leaflet() %&gt;% addTiles() ``` 需要注意的是，require('package') 只有当这个包已安装且可使用时才会返回TRUE，否则会返回FALSE。 9.2 如何在遇到 error 的时候继续编译 有时你可能想要故意显示错误（例如，在关于R的教程中），然而，在默认情况下，R Markdown文档中代码块中的错误将使程序终止。如果你想在不终止R程序的情况下显示错误，你可以使用块选项error = TRUE，例如： ```{r, error=TRUE} 1 + &quot;a&quot; ``` 这样在编译R Markdown文档后，你将在输出文档中看到如下的错误消息： Error in 1 + &quot;a&quot;: non-numeric argument to binary operator 需要注意的是，在R Markdown中，默认设定为error = FALSE，这也导致了R在运行代码块时，出现错误就会终止。 9.3 同一张图的多种图像输出格式 在大多数情况下，你可能只需要一种图像格式，例如png或pdf。图像格式由块选项dev控制，即渲染图像的图像设备，这个选项的取值可以为多种设备名（即输出格式）的向量，例如： ```{r, dev=c(&#39;png&#39;, &#39;pdf&#39;, &#39;svg&#39;, &#39;tiff&#39;)} plot(cars) ``` 输出文档中只会呈现第一种格式的图像，但也其它格式的图像也会被生成，当你需要另外提交不同格式的图像时（例如，你在报告中显示一个png格式的图像，但同时也需要tiff格式的图像），会起到很大的帮助。 需要注意的是，在默认情况下，图像文件在输出文档呈现后即被删除，如要保存这些文件，请参见??节。 9.4 缓存耗时的代码块 当一个代码块运行起来很费时间时，你可以考虑通过块选项cache = TRUE来缓存它。当启用缓存时，如果一个代码块之前被执行过且之后没有任何变化时，knitr将跳过这个代码块的执行。当你修改代码块时（如修改代码或块选项），之前的缓存将自动失效，并且knitr将再次运行并缓存该代码块。 对于一个被缓存了的代码块，它的输出以及变量对象将从上一次的运行中自动加载，就像该代码块再次执行了一样。当加载结果比计算结果快得多时，缓存操作通常是有用的。然而，天下没有免费的午餐，有的时候knitr经常会令缓存失效或是部分失效，为此你可能需要了解更多关于如何缓存，特别是缓存失效的相关知识：https://yihui.org/en/2018/06/cache-invalidation/。 一个典型的缓存用例是保存和重新加载那些需要很长时间才能在代码块中计算的R对象。需要注意的是，代码需要没有任何副作用，否则我们建议您不要进行缓存（例如options()更改全局R选项，这样的更改不会被缓存）。 正如我们前面简要提到的，缓存依赖于块选项。如果你改变了任何块选项（除了include选项），缓存将会失效。此特性可用于解决一个常见的问题，即当你读取外部数据文件时，你可能希望在更新数据文件时使缓存失效，这样的话像下面这样简单地使用cache = TRUE是不够的： ```{r import-data, cache=TRUE} d &lt;- read.csv(&#39;my-precious.csv&#39;) ``` 你必须要让knitr知道数据文件是否已被更改。一种方法是添加另一个块选项cache.extra = file.mtime('my-precious.csv')，或者更严格的方式：cache.extra = tools::md5sum('my-precious.csv')。前者意味着如果文件的修改时间发生了变化，我们就需要使缓存失效；而后者的意思是，如果文件的内容被修改，我们就更新缓存。需要注意的是，cache.extra不是一个内置的knitr 代码选项，你可以为该选项使用任何其他名称，只要它不与内置选项名称冲突。 类似地，你可以将缓存与其他信息相关联，比如R的版本（cache.extra = getRversion()）、时间（cache.extra = Sys.Date()）或是你的操作系统（cache.extra = Sys.info()[['sysname']]）， 当这些条件改变时，可以使缓存正确地失效。 我们不建议在文档中设置全局块选项cache = TRUE，因为缓存可能相当棘手。相反的，我们建议您只在个别耗时很久的代码块上启用缓存，这样并不会产生副作用。 如果你对knitr的缓存设计不满意，当然你可以选择自己缓存对象，下面是一个简单的例子： if (file.exists(&#39;results.rds&#39;)) { res = readRDS(&#39;results.rds&#39;) } else { res = compute_it() # 一个很耗时的函数 saveRDS(res, &#39;results.rds&#39;) } 在这一例子中，使缓存失效的唯一（也是简单的）方法就是删除文件results.rds。如果你喜欢这个简单的缓存机制，可以使用在11.9节中介绍的函数xfun::cache_rds()。 9.5 为多种输出格式缓存代码块 当通过块选项cache = TRUE启用缓存时，knitr将把在代码块中生成的R对象写入缓存数据库，以便下次重新加载它们。缓存数据库的路径由块选项cache.path决定。默认情况下，R Markdown对不同的输出格式会使用不同的缓存路径，这意味着对于每种输出格式都将完全执行一次这个（耗时的）代码块。这可能很不方便，但这种默认的行为是有原因的，即代码块的输出可能依赖于特定的输出格式。例如，当你生成一个图像时，当输出格式为word_document时，图像的输出可能是像 ![text](path/to/image.png)这样的标记代码，而或者当输出格式为html_document时，输出的HTML代码则类似&lt;img src=\"path/to/image.png\" /&gt;。 当代码块没有任何副产物（如图像）时，对所有输出格式使用相同的缓存数据库是安全的，这可以节省你的时间。例如，当你读取一个大型数据对象或运行一个比较耗时的模型时，若结果不依赖于输出格式，你就可以使用相同的缓存数据库。你可以通过块选项cache.path指定数据库的路径，例如： ```{r important-computing, cache=TRUE, cache.path=&quot;cache/&quot;} ``` 在R Markdown中，cache.path的默认设置为cache.path = \"INPUT_cache/FORMAT/\"，其中INPUT代表输入的文件名，FORMAT为输出格式（如html、latex或docx）。 9.6 缓存大型的对象 当设定块选项cache = TRUE时，缓存的对象将被延迟加载到R中，这意味着对象将不会从缓存数据库中读取，直到它在代码中被实际使用。当不是所有对象都在文档中稍后被使用时，这一操作可以节省一些内存。例如，如果你读取了一个大型的数据对象，但在后续的分析中只使用了其中的一个子集，那么原始的数据对象将不会从缓存数据库中加载： ```{r, read-data, cache=TRUE} full &lt;- read.csv(&quot;HUGE.csv&quot;) rows &lt;- subset(full, price &gt; 100) # 之后我们只用 `rows` ``` ```{r} plot(rows) ``` 然而，当一个对象太大时，你可能会遇到这样的报错： Error in lazyLoadDBinsertVariable(vars[i], ... long vectors not supported yet: ... Execution halted 如果出现这个问题，你可以尝试通过块选项cache.lazy = FALSE来关闭延迟加载，这样该代码块中的所有对象都将立即被加载到内存中。 9.7 隐藏源代码、message、warning、文本输出或图像输出 默认情况下，knitr会显示代码块的所有可能输出，包括源代码、message、warning、文本输出和图像输出，你可以使用相应的块选项来单独隐藏它们。 隐藏源代码： ```{r, echo=FALSE} 1 + 1 ``` 隐藏message： ```{r, message=FALSE} message(&quot;你不会看到这个message.&quot;) ``` 隐藏warning： ```{r, warning=FALSE} # 这将生成一个warning，但不会被输出 1:2 + 1:3 ``` 隐藏文本输出（你也可以使用`results = FALSE`）： ```{r, results=&#39;hide&#39;} print(&quot;你不会看到这个文本输出。&quot;) ``` 隐藏图形输出： ```{r, fig.show=&#39;hide&#39;} plot(cars) ``` 需要注意的是，上面的代码块会生成图形，它只是没有显示在输出中而已。 关于knitr的一个常见问题是如何隐藏包的加载消息。例如，当你使用library(tidyverse)或library(ggplot2)时，你可能会看到一些正在加载的message。这类message也可以通过块选项message = FALSE来抑制。 还可以通过索引来有选择地显示或隐藏这些元素。在下面的示例中，我们只输出了源代码的第四个和第五个表达式（注意，一个注释会被算作一个表达式）、前两个message以及第二个和第三个warning： ```{r, echo=c(4, 5), message=c(1, 2), warning=2:3} # 一种生成服从N(0,1)分布的随机数的方法（连续随机变量的分布函数服从U(0,1)分布） x &lt;- qnorm(runif(10)) # 在实践中我们还可以使用 x &lt;- rnorm(10) x for (i in 1:5) message(&#39;Here is the message &#39;, i) for (i in 1:5) warning(&#39;Here is the warning &#39;, i) ``` 你还可以使用负索引，例如，echo = -2表示在输出中排除源代码的第二个表达式。 类似地，你可以通过使用fig.keep选项来选择显示或隐藏哪些图。例如，fig.keep = 1:2意味着保留前两幅图。这个选项有一些快捷的方式，如fig.keep = \"first\"将只保留第一幅图、fig.keep = \"last\"只保留最后的图以及fig.keep = \"none\"将丢弃所有的图。注意fig.keep = \"none\"和fig.show = \"hide\"这两个选项是不同的，后者将生成图像文件，但只隐藏它们，而前者根本不会生成图像文件。 对于html_document输出中的源代码块，如果你不想完全省略它们（echo = FALSE），你可以参考??节，来学习如何在页面上折叠它们，并允许用户通过单击展开按钮来展开它们。 9.8 隐藏代码块的所有输出 有的时候，我们可能想要执行一个代码块而根本不显示任何输出。与使用9.7节中提到的单独选项不同，我们可以使用一个选项’include = FALSE`来隐藏代码块所有的输出，例如： ```{r, include=FALSE} # 任意的R代码 ``` 使用include=FALSE，代码块将被运行（除非eval=FALSE），但输出将被完全隐藏，你将看不到任何的源代码、message、warning、文本输出或图像输出。 9.9 将文本输出压缩到源代码块中 如果你觉得输出结果中的文本输出部分和源代码部分之间有太多的间隔，你可以考虑使用块选项collapse = TRUE将文本输出压缩到源代码块中。collapse = TRUE时的输出如下所示： 1 + 1 ## [1] 2 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 若没有设定collapse = TRUE（默认为FALSE），则会变成： 1 + 1 ## [1] 2 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 9.10 重新格式化源代码 当你设置块选项tidy = TRUE时， R的源代码将被formatR包 (Xie 2021a)的tidy_source()函数重新格式化。tidy_source()可以在几个方面重新格式化代码，比如在大多数操作符周围添加空格、适当缩进代码以及用&lt;-替换赋值操作符= 。块选项tidy.opts可以是传递给formatR::tidy_source()的一个参数列表，例如： ```{r, tidy=TRUE, tidy.opts=list(arrow=TRUE, indent=2)} # 混乱的 R 代码... 1+ 1 x=1:10#有些使用者更喜欢用 &#39;&lt;-&#39; 来作为赋值操作符 if(TRUE){ print(&#39;Hello world!&#39;) # 缩进 2 个空格 } ``` 输出结果为： # 混乱的 R 代码... 1 + 1 x &lt;- 1:10 #有些使用者更喜欢用 &#39;&lt;-&#39; 来作为赋值操作符 if (TRUE) { print(&quot;Hello world!&quot;) # 缩进 2 个空格 } 在??节中，我们提到了如何控制文本输出的宽度。如果你想控制源代码的宽度，你可以在设置tidy = TRUE时使用width.cutoff参数，例如： ```{r, tidy=TRUE, tidy.opts=list(width.cutoff=50)} # 一个很长的表达式 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+ 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1 ``` 输出结果为： # 一个很长的表达式 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 更多可能的参数可以参见帮助页?formatR::tidy_source，也可以浏览 https://yihui.org/formatR/ 来了解这个函数的示例和局限性。 另外，如果你设定块选项tidy = 'styler'，你也可以使用styler包(R-styler?)来重新格式化你的R代码，其中的格式化函数为styler::style_text()。styler包比formatR具有更丰富的特性。例如，它可以对齐函数参数并使用管道操作符’%&gt;%。块选项tidy.opts同样可以用于将附加参数传递给styler::style_text()，例如： ```{r, tidy=&#39;styler&#39;, tidy.opts=list(strict=FALSE)} # 对齐赋值操作符 a &lt;- 1#一个变量 abc &lt;- 2#另一个变量 ``` 在默认情况下，tidy = FALSE并且你的R代码不会被重新格式化。 9.11 将输出文本作为原始的Markdown的内容 (*) 默认情况下，代码块的文本输出将逐字输出，并添加两个前导符号##（见9.12节）。由于knitr将文本放在隔离的代码块中，所以文本是逐字的。例如，对于代码1:5，knitr的原始输出为： ``` ## [1] 1 2 3 4 5 ``` 有时你可能不希望逐字输出文本，而是将文本输出视为Markdown的内容。例如，你可能想写一个类似cat('# 这是一个标题')的节标题，但原始的输出是： ``` ## # 这是一个标题 ``` 你不希望文本位于隔离的代码块（或开头的##）中，也就是说，你希望原始输出与传递给cat()的字符串完全一致： # 这是一个标题 这个问题的解决方案是块选项’results = 'asis'。这个选项告诉knitr不要将文本输出逐字包装成代码块，而是“原样”对待它。当你想要从R代码动态生成内容时，这一点特别有用。例如，你可以使用选项results = 'asis'从以下代码块生成iris数据的列名列表: cat(paste0(&#39;- `&#39;, names(iris), &#39;`&#39;), sep = &#39;\\n&#39;) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 连字符（-）是Markdown中用于生成无序列表的语法，其中反引号是可选的。若没有设置results = 'asis'选项，则上述代码块的输出为： cat(paste0(&#39;- `&#39;, names(iris), &#39;`&#39;), sep = &#39;\\n&#39;) - `Sepal.Length` - `Sepal.Width` - `Petal.Length` - `Petal.Width` - `Species` 下面是一个完整的例子，展示了如何在for循环中为mtcars数据的所有列生成节标题、段落和图： --- title: 以编程的方式生成内容 --- 通过代码块选项`results = &#39;asis&#39;`，你可以将文本作为原始的Markdown内容写出来，同时也可以与图片混合。 ```{r, mtcars-plots, results=&#39;asis&#39;} for (i in names(mtcars)) { cat(&#39;\\n\\n# 变量 `&#39;, i, &#39;` 的概要\\n\\n&#39;) x &lt;- mtcars[, i] if (length(unique(x)) &lt;= 6) { cat(&#39;`&#39;, i, &#39;` 是一个分类变量。\\n\\n&#39;) plot(table(x), xlab = i, ylab = &#39;频率&#39;, lwd = 10) } else { cat(&#39;连续变量 `&#39;, i, &#39;` 的直方图。\\n\\n&#39;) hist(x, xlab = i, main = &#39;&#39;) } } ``` 需要注意的是，我们在代码中添加了过多的换行符（\\n），这是因为我们希望不同的元素在Markdown的内容中清晰地分开。在不同的元素之间使用过多的换行符是无害的，但是如果换行符不够，就会产生问题。例如，下面的Markdown文本就会产生很多的歧义： # 这是一个标题吗？ 这是一个段落还是标题的一部分呢？ ![这张图片呢？](foo.png) # 这行又是什么？ 如果产生了更多的空行（可以由cat('\\n')生成），则歧义就会消失： # 这是一个标题！ 这绝对是个段落。 ![这是一张图。](foo.png) # 这是另一个标题 cat()函数不是唯一可以生成文本输出的函数，另一个常用的函数是print()。需要注意的是，print()经常被 隐式 调用来打印对象，这就是为什么你在R控制台（console）中输入一个对象或值后会看到输出。例如，当你在R控制台中输入1:5并按下Enter键时，你会看到输出，因为R实际上隐式地调用了print(1:5)。经常令人感到困惑的是，你不能在表达式（例如for循环）中直接生成输出，而如果在R控制台上输入对象或值，它们将被正确打印出来。这个主题非常技术性，具体细节可以参看博文“The Ghost Printer behind Top-level R Expressions”。如果你对技术细节不感兴趣，只要记住这条规则即可：如果你没有看到for循环的输出，那么你可能应该使用print()函数来显式地打印对象。 9.12 删除文本输出中的前导符号 默认情况下，R代码输出将在文本输出的前面插入两个符号##。我们可以通过块选项comment 来改变这种输出。如果要删除##，可以使用空字符串，例如: ```{r, comment=&quot;&quot;} 1:100 ``` 当然，你可以使用任何其他的字符值，例如，comment = \"#&gt;\"。那么为什么comment选项默认为##呢？这是因为#表示R中的注释，当文本输出被注释掉时，从报告中的代码块中一次性复制所有代码并自己运行它将更容易，不需要担心运行文本输出（并非R代码）会报错。例如，在下面的代码块中，你可以复制所有四行文本，并将它们作为R代码正确地运行： 1 + 1 ## [1] 2 2 + 2 ## [1] 4 而如果你通过comment = \"\"删除##，你通常会无法直接运行所有的代码。如下面的例子所展示的，如果你直接复制这四行，你将不得不手动删除第二和第四行： 1 + 1 [1] 2 2 + 2 [1] 4 设置comment = \"\"的一个理由是，使用R控制台（console）的用户对其更为熟悉。在R控制台中，你不会在文本输出前面看到##。如果你想真正模仿R控制台的行为，你可以将comment = \"\"和prompt = TRUE结合在一起使用，例如： ```{r, comment=&quot;&quot;, prompt=TRUE} 1 + 1 if (TRUE) { 2 + 2 } ``` 如果你曾经在R控制台中输入并运行过代码，那么输出结果看起来应该相当熟悉，因为源代码中包含提示字符（prompt character）&gt;和延续字符（continuation character）+： &gt; 1 + 1 [1] 2 &gt; if (TRUE) { + 2 + 2 + } [1] 4 9.13 为文本输出块添加属性 (*) 在??节中，我们展示了一些基于块选项class.source和class.output样式化代码块和文本输出块的示例。实际上，在knitr中有更多类似的选项，如class.message、class.warning以及class.error。这些选项可以用于将类名添加到相应的文本输出块中，例如error = TRUE（见9.2节）。这些选项最常见的应用可能是使用根据类名定义的CSS规则对输出块进行样式化，就像在??节中演示的那样。 通常情况下，文本输出块本质上是一个单独的代码块，它的Markdown源代码如下所示： ```{.className} 输出行 ``` 当输出格式为HTML时，通常会转换为9: &lt;pre class=&quot;className&quot;&gt; &lt;code&gt;输出行&lt;/code&gt; &lt;/pre&gt; class.*选项控制了&lt;pre&gt;元素中的class属性，而&lt;pre&gt;是我们上面提到的文本输出块的“容器”。 事实上，这个类只是HTML中&lt;pre&gt;元素可能的属性之一。一个HTML元素可以有许多其他属性，比如宽度、高度和样式等。块选项attr.*,包括attr.source、attr.output、attr.message、attr.warning以及attr.error，允许你向文本输出块添加任意属性。例如，使用attr.source = 'style=\"background: pink;\"'，你可以将源代码块的背景颜色更改为粉红色，相应的代码块将是 ```{style=&quot;background: pink;&quot;} ... ``` 以及HTML输出会是： &lt;pre style=&quot;background: pink;&quot;&gt; ... &lt;/pre&gt; 更多的例子可以参见??节和10.3节。 作为一个技术说明，块选项class.*只是attr.*的特殊情况，例如，class.source = 'numberLines'等价于attr.source = '.numberLines'（注意这里的前导点），但attr.source可以取任意的属性值，例如attr.source = c('.numberLines', 'startFrom=\"11\"')。 这些选项对HTML输出非常有用。在某些情况下，这些属性可能对其他输出格式也有用，但这种情况相对较少。这些属性需要被Pandoc或第三方的包支持。例如Pandoc中，.numberLines属性适用于HTML和LaTeX输出；第三方的包则通常需要通过一个Lua过滤器，详情请参见??节。 9.14 图像的后期加工 (*) 代码块生成图像后，你可以通过块选项fig.process对图像文件进行后期加工。处理过程应该是一个输入文件路径，返回已处理图像文件路径的函数。该函数可以有第二个可选参数options，代表一个由当前块选项组成的列表。 下面我们展示了一个使用功能强大的magick包 (Ooms 2021)来在图像中添加R logo的例子。如果你不熟悉这个包，可以阅读它的在线文档或包简介，其中包含许多示例。首先，我们定义一个函数add_logo()： install.packages(&quot;magick&quot;) add_logo = function(path, options) { # 代码块中创建的图像 img = magick::image_read(path) # R logo logo = file.path(R.home(&quot;doc&quot;), &quot;html&quot;, &quot;logo.jpg&quot;) logo = magick::image_read(logo) # 默认的重力方向为西北，用户可以通过代码块来改变它 # option magick.gravity if (is.null(g &lt;- options$magick.gravity)) g = &#39;northwest&#39; # 在图像中添加 logo img = magick::image_composite(img, logo, gravity = g) # 写入新的图像中 magick::image_write(img, path) path } 该函数会读取图像的路径，添加R logo，并将新图像保存到原路径。在默认情况下，logo会被添加到图像的左上角（西北方向），但用户可以通过自定义块选项magick.gravity（这个选项名可以是任意的）来自定义位置。 现在我们将上面的处理函数应用到下面的代码块上，并使用块选项fig.process = add_logo 和 magick.gravity = \"northeast\"，所以logo会被添加到右上角。实际输出见图 9.1。 par(mar = c(4, 4, .1, .1)) hist(faithful$eruptions, breaks = 30, main = &#39;&#39;, col = &#39;gray&#39;, border = &#39;white&#39;) 图 9.1: 通过块选项 fig.process 来给一幅图添加 R logo。 在你对magick包更加熟悉后，你就可以通过更有创意和有用的想法来后期加工你的图像。 最后，我们展示了fig.process选项的另一个应用。下例中的pdf2png()函数可以将PDF图像转换成PNG格式。在9.15节中，我们有一个使用tikz图像设备来生成图的例子。但问题是，该设备生成的PDF图不适用于非LaTeX的输出文档。在设置块选项dev = \"tikz\" 和 fig.process = pdf2png后，我们可以显示PNG版本的图 9.2。 pdf2png = function(path) { # 只对非LaTeX的输出进行转换 if (knitr::is_latex_output()) return(path) path2 = xfun::with_ext(path, &quot;png&quot;) img = magick::image_read_pdf(path) magick::image_write(img, path2, format = &quot;png&quot;) path2 } 9.15 高质量的图像 (*) rmarkdown包为不同的输出格式设置了合理的默认图像设备。例如，HTML输出格式使用png()设备，所以knitr将生成png绘图文件；而PDF输出格式则使用pdf()设备。如果你对默认图像设备的输出质量不满意，你可以通过块选项dev来更改它们。knitr支持的设备为：\"bmp\"，\"postscript\"，\"pdf\"，\"png\"，\"svg\"，\"jpeg\"，\"pictex\"，\"tiff\"，\"win.metafile\"，\"cairo_pdf\"，\"cairo_ps\"，\"quartz_pdf\"，\"quartz_png\"，\"quartz_jpeg\"，\"quartz_tiff\"，\"quartz_gif\"，\"quartz_psd\"，\"quartz_bmp\"，\"CairoJPEG\"，\"CairoPNG\"，\"CairoPS\"，\"CairoPDF\"，\"CairoSVG\"，\"CairoTIFF\"，\"Cairo_pdf\"，\"Cairo_png\"，\"Cairo_ps\"，\"Cairo_svg\"，\"svglite\"，\"ragg_png\"，以及\"tikz\"。 通常情况下，图像设备名也是函数名。更多关于设备的信息请参阅R的帮助页面。例如，你可以在R的控制台中输入?svg来了解关于svg设备的细节，它包含在R的基础包中，所以不需要额外安装。需要注意的是，quartz_XXX设备是基于quartz()函数的，并且它们仅在macOS上可用；CairoXXX设备来自附加的R包cairoDevice(R-cairoDevice?)；svglite设备来自svglite 包 (R-svglite?)；tikz设备在tikzDevice 包 (Sharpsteen and Bracken 2020)中。如果你想使用附加包中的设备，你必须先安装这个包。 通常，矢量图比位图质量更高，并且你可以在不损失质量的情况下缩放矢量图。对于HTML输出，你可以使用dev = \"svg\"或dev = \"svglite\"来绘制SVG（可缩放矢量图，Scalable Vector Graphics）。需要注意的是，默认情况下png设备生成的图像为位图。 对于PDF输出，如果你对图像中的字体非常挑剔，可以使用dev = \"tikz\"，因为它提供了对LaTeX的原生支持，这意味着图像中的所有元素，包括文本和符号，都可以通过LaTeX以高质量呈现。图 9.2展示了一个在R图像中用块选项’dev = \"tikz\"添加LaTeX数学表达式的例子。 par(mar = c(4, 4, 2, .1)) curve(dnorm, -3, 3, xlab = &#39;$x$&#39;, ylab = &#39;$\\\\phi(x)$&#39;, main = &#39;The density function of $N(0, 1)$&#39;) text(-1, .2, cex = 3, col = &#39;blue&#39;, &#39;$\\\\phi(x)=\\\\frac{1}{\\\\sqrt{2\\\\pi}}e^{\\\\frac{-x^2}{2}}$&#39;) 图 9.2: 通过 tikz 设备呈现的图像。 需要注意的是，R的基础包实际上支持数学表达式，但它们不是通过LaTeX呈现的（具体细节可参见?plotmath）。此外，有几个高级选项可以调整tikz设备的排版细节（参见?tikzDevice::tikz）。例如，如果你的图像中包含多字节字符，你可以设置选项： options(tikzDefaultEngine = &#39;xetex&#39;) 这是因为在处理LaTeX文档中的多字节字符时，xetex通常比默认引擎pdftex要好。 tikz设备主要有两个缺点。首先，它需要安装LaTeX，但这其实并不会很麻烦（见??节），你还需要几个LaTeX包，这些包可以通过TinyTeX很方便地安装： tinytex::tlmgr_install(c(&#39;pgf&#39;, &#39;preview&#39;, &#39;xcolor&#39;)) 其次，tikz设备渲染图的速度通常要慢得多，因为这个设备会生成LaTeX文件，并且必须将其编译成PDF。如果你觉得代码块很耗时，你可以通过块选项cache = TRUE来启用缓存（见9.4节）。 对于图 9.2，我们也使用了块选项fig.process = pdf2png，其中当输出格式不是LaTeX时，pdf2png函数可以将PDF图转换为PNG，其定义见 9.14节。如果没有这一转换，你可能无法在web浏览器中查看该书在线版本中的PDF图。 9.16 带有低级绘图功能的逐步绘图 (*) 在R中，有两种类型的绘图函数可以用来画图：高级的绘图函数用于创建新图，以及低级的绘图函数用于在现有的图中添加元素，更多信息请参见R手册《An Introduction to R》的第12章（“Graphical procedures”）。 在默认的情况下，当使用一系列低级的绘图函数来修改以前的图像时，knitr不显示中间的图，只显示所有函数执行后的最后一个图。 然而有的时候，尤其是在教学过程中，展示中间的图像是很有用的。为此，你可以设置块选项fig.keep = 'low'来保留各低级函数更改后的图。例如，图9.3和图9.4来自一个带有块选项fig.keep = 'low'的单个代码块，尽管它们很像两个代码块的输出结果。不仅如此，我们还通过块选项fig.cap=c('cars ...', '在现有的...')给它们分配了不同的标题。 par(mar = c(4, 4, .1, .1)) plot(cars) 图 9.3: cars 数据的点图 fit = lm(dist ~ speed, data = cars) abline(fit) 图 9.4: 在现有的点图中添加一条回归线 如果你想在不同的代码块中继续修改这张图，请参阅11.5节。 9.17 在代码块中自定义对象的打印格式 (*) 在默认的情况下，代码块中的对象通过knitr::knit_print()函数来打印，基本上就是R中的print()。knit_print()函数是一个S3通用函数，这意味着你可以通过在其上注册S3方法来拓展输出方式。下面的例子展示了如何通过knitr::kable()来自动将数据框打印成表格： --- title: 使用使用自定义的 `knit_print` 方法来打印数据框 --- 首先，我们定义一个`knit_print`方法，并且注册它： ```{r} knit_print.data.frame = function(x, ...) { res = paste(c(&quot;&quot;, &quot;&quot;, knitr::kable(x)), collapse = &quot;\\n&quot;) knitr::asis_output(res) } registerS3method( &quot;knit_print&quot;, &quot;data.frame&quot;, knit_print.data.frame, envir = asNamespace(&quot;knitr&quot;) ) ``` 现在我们可以在数据框上测试这个自定义的打印方法。 注意，你不再需要显式地调用`knitr::kable()`了。 ```{r} head(iris) ``` ```{r} head(mtcars) ``` 更多关于knit_print()函数的信息可参见knitr包的简介： vignette(&#39;knit_print&#39;, package = &#39;knitr&#39;) printr包 (R-printr?)提供了一些S3方法来自动将R对象打印为表格。你只需要在R代码块中输入library(printr)，这一所有的方法都将自动注册。 如果你觉得这个技术对你来说太高级了，一些R Markdown输出格式，如html_document’和pdf_document也提供了一个选项df_print，它允许你自定义数据框的打印行为。例如，如果你想通过knitr::kable()来将数据框打印为表格，你可以设置选项： --- output: html_document: df_print: kable --- 有关输出格式的更多细节可参阅输出格式的帮助页（如?rmarkdown::html_document），可以帮助你了解df_print选项支持哪些输出格式，以及对应的值是什么。 事实上，你可以通过块选项render来完全代替打印函数knit_print()，render可以使用任何函数来打印对象。例如，如果你想使用pander包来打印对象，你可以设置块选项render为函数pander::pander()： ```{r, render=pander::pander} iris ``` render选项给了你完全的自由来打印你的R对象。 9.18 选项钩子 (*) 有时候，你可能想要更具其他块选项的值，来动态地改变某个块选项 ，你可以使用对象opts_hooks来设置一个选项钩子（option hook）来实现这个功能。选项钩子是一个与该选项相关的函数，会在对应的块选项不是NULL时自动执行。这个函数将当前代码块的选项列表作为输入参数，并且会返回一个（可能是修改过的）列表。例如，我们可以调整fig.width选项，使它总是不小于fig.height： knitr::opts_hooks$set(fig.width = function(options) { if (options$fig.width &lt; options$fig.height) { options$fig.width = options$fig.height } options }) 因为fig.width永远不会是NULL，所以这个钩子函数总是在代码块之前执行，以更新它的块选项。对于下面的代码块，如果设置了上述的选项钩子，则fig.width的实际值将是6而不是最初的5： ```{r fig.width = 5, fig.height = 6} plot(1:10) ``` 作为另一个例子，我们重写了9.12节中的最后一个例子，这样我们就可以使用一个单独的块选项console = TRUE来代表comment = \"\"和prompt = TRUE。需要注意的是，console不是一个内置的knitr 块选项，而是一个自定义的任意的选项名，它的默认值是NULL。下面是一个完整的例子： ```{r, include=FALSE} knitr::opts_hooks$set(console = function(options) { if (isTRUE(options$console)) { options$comment &lt;- &#39;&#39;; options$prompt &lt;- TRUE } options }) ``` 默认输出为： ```{r} 1 + 1 if (TRUE) { 2 + 2 } ``` 设置 `console = TRUE` 时的输出为： ```{r, console=TRUE} 1 + 1 if (TRUE) { 2 + 2 } ``` 第三个例子介绍了如何自动向输出块添加行号，输出块可以包括源代码块、文本输出、message、warning以及报错。我们在??节中已经提到了如何使用块选项，如attr.source 和 attr.output来添加行号，这里我们想使用单个的块选项（本例中为numberLines）来控制我们想要添加行号的输出块。 knitr::opts_hooks$set( numberLines = function(options) { attrs &lt;- paste0(&quot;attr.&quot;, options$numberLines) options[attrs] &lt;- lapply(options[attrs], c, &quot;.numberLines&quot;) options } ) knitr::opts_chunk$set( numberLines = c( &quot;source&quot;, &quot;output&quot;, &quot;message&quot;, &quot;warning&quot;, &quot;error&quot; ) ) 基本上，选项挂钩numberLines将属性.numberLines附加到输出块上，并且通过opts_chunk$set()来设置块选项numberLines，从而确保选项挂钩会被执行。 通过以上设置，你可以在代码块上使用选项numberLines来决定它的哪些输出块将具有行号，例如numberLines = c('source', 'output')；而设定numberLines = NULL则将完全删除行号。 你可能想知道这种方法与直接设置块选项有何不同，例如，就像在??节那样，我们可以仅设置knitr::opts_chunk$set(attr.source = '.numberLines')。本节介绍的选项钩子的优点是，它们只在块选项中附加属性.numberLines，这意味着它们不会覆盖现有的块选项值，例如，下面代码块中的源代码块将被编号（使用上面的设置），并且编号会从第二行开始: ```{r, attr.source=&#39;startFrom=&quot;2&quot;&#39;} # 这行注释不会被编号 1 + 1 ``` 这等价于： ```{r, attr.source=c(&#39;startFrom=&quot;2&quot;&#39;, &#39;.numberLines&#39;} # 这行注释不会被编号 1 + 1 ``` 也可以转换为&lt;div class=\"className\"&gt;&lt;/div&gt;，可以查看HTML输出文档的源代码来确定↩︎ "],["output-hooks.html", "第 10 章 输出钩子 (*) 10.1 编辑源代码 10.2 向源代码中添加行号 10.3 可滚动的文本输出 10.4 截断文本输出 10.5 以HTML5格式输出图像", " 第 10 章 输出钩子 (*) 通过使用knitr包，您可以控制代码块的每一段输出，如源代码、文本输出、图像输出以及message等，这一控制是通过“输出钩子”（Output Hook）实现的。输出钩子是一系列函数，它们的输入为一段输出（通常是一个字符向量），并返回一个要写入输出文档的字符向量。到目前为止这个说法可能不容易理解，但希望你可以通过下面的一个例子来更清楚地理解这个想法，这个小例子解释了一个简单代码块的输出是如何通过knitr的输出钩子呈现的，这里我们考虑一个由一行代码组成的代码块： ```{r} 1 + 1 ``` 在knitr对代码块进行处理后，它会得到两个输出元素，它们都存储为字符串：源代码\"1 + 1\"和文本输出\"[1] 2\"。这些字符串将由块挂钩（chunk hooks）进一步处理，以获得所需的输出格式。例如，对于Markdown文档，knitr将把源代码包装在带有编程语言名称的代码块中。这是通过source钩子完成的，它看起来像这个函数： # 对于上面的例子， `x` 为字符串 &quot;1 + 1&quot; function(x, options) { # 小写的 &quot;r&quot; 在这里表示编程语言的名称 paste(c(&#39;```r&#39;, x, &#39;```&#39;), collapse = &#39;\\n&#39;) } 类似的，由输出钩子处理的文本输出类似于下面这个函数； function(x, options) { paste(c(&#39;```&#39;, x, &#39;```&#39;), collapse = &#39;\\n&#39;) } 所以上述代码块的最终输出为： ```r 1 + 1 ``` ``` [1] 2 ``` 实际的钩子比上面的两个函数更复杂，但背后的思想是一样的。你可以通过get()方法从knit_hooks获得实际的钩子，例如： # 为了得到有意义的输出，以下代码应在一个 knitr 文档的代码块内部执行 knitr::knit_hooks$get(&#39;source&#39;) knitr::knit_hooks$get(&#39;output&#39;) # 或者 knitr::knit_hooks$get(c(&#39;source&#39;, &#39;output&#39;)) 除非你真的有兴趣为knitr包做贡献，否则我们不建议你阅读这些内置钩子的源代码。如果你感兴趣，可以在 https://github.com/yihui/knitr/tree/master/R 里以hooks-*.R形式命名的脚本中找到这些代码（例如，hooks-md.R包含R Markdown文档的钩子）。作为knitr用户，如果你知道如何利用内置钩子创建自定义输出钩子，通常就足够了。你将在本章的几个例子中学习到这一点，我们将在下面展示基本的思想。 一个自定义的输出钩子是通过knit_hooks的set()方法注册的。由于该方法将覆盖现有的默认钩子，我们建议先保存默认钩子的副本，以自己的方式处理输出元素，并将结果传递给默认钩子。常见的语法为： # 在这里使用 local() 是可选的，我们只是想避免创建不必要的全局变量，如 `hook_old`） local({ hook_old = knitr::knit_hooks$get(&#39;NAME&#39;) # 保存现有的钩子 knitr::knit_hooks$set(NAME = function(x, options) { # 现在可以对 x 做任何处理，并将 x 传递给现有的钩子 hook_old(x, options) }) }) 这里，NAME是钩子的名称，它可以是以下值之一： source： 处理源代码； output： 处理文本输出； warning： 处理 warning （通常来自 warning()）； message： 处理 message （通常来自 message()）； error： 处理 error message （通常来自 stop()）； plot： 处理图像输出路径； inline： 处理行内 R 表达式的输出； chunk： 处理整个块的输出； document： 处理整个文档的输出。 钩子函数中的参数x的含义在上面的列表中解释。对于钩子的options 参数，它表示当前代码块的块选项（以列表形式给出）。例如，如果你在一个块上设置foo = TRUE，你可以通过钩子中的options$foo获取它的值。但需要注意的是，参数options对inline和document 钩子不可用。 输出钩子可以让你能够最终控制块和文档输出的每个单独部分。与块选项（通常具有预定义的用途）相比，输出钩子可能要强大得多，因为它们是用户自定义的函数，而且你可以在函数中做任何你想做的事情。 10.1 编辑源代码 有时我们可能不希望在报告中完全展示我们的源代码。例如，你可能在某一行代码中需要写一个密码（如爬虫代码等）。我们在9.7节中提到，你可以使用块选项echo来选择显示哪个表达式（例如，通过echo = 2可以显示第二个表达式）。在本节中，我们提供了一种更加灵活的方法，它不需要指定表达式的位置或索引。 它的基本思想是在代码中添加一个特殊的注释（例如，# SECRET!!）。当在代码中检测到该注释时，将自动忽略该行。下面是使用source钩子的完整示例: --- title: 用`source`钩子来隐藏某行代码 --- 首先，我们设置一个`source`钩子来匹配并隐藏（排除）末尾处包含字符串`# SECRET!!`的代码行： ```{r, include=FALSE} local({ hook_source &lt;- knitr::knit_hooks$get(&#39;source&#39;) knitr::knit_hooks$set(source = function(x, options) { x &lt;- x[!grepl(&#39;# SECRET!!$&#39;, x)] hook_source(x, options) }) }) ``` 现在我们可以测试这个新的钩子。在编译这个文档时，你将看不到带有特殊注释`# SECRET!!`的代码行。 ```{r} 1 + 1 # 正常显示代码 # 请使用你的用户名及密码 auth &lt;- httr::authenticate(&quot;user&quot;, &quot;passwd&quot;) auth &lt;- httr::authenticate(&quot;yihui&quot;, &quot;horsebattery&quot;) # SECRET!! httr::GET(&quot;http://httpbin.org/basic-auth/user/passwd&quot;, auth) ``` 上述source钩子的关键部分为下面这一行，它会通过grepl()来匹配源代码向量x中末尾处包含注释# SECRET!!的代码行，并隐藏（排除）它们： x &lt;- x[!grepl(&#39;# SECRET!!$&#39;, x)] 准确地说，上述的钩子将隐藏（排除）所有末尾处包含注释# SECRET!!的 表达式，而非单独的行，因为x 实际上是一个由R中表达式组成的向量。例如，对于下面的代码块： 1 + 1 if (TRUE) { # SECRET!! 1:10 } 在source钩子中，x的值为： c(&quot;1 + 1&quot;, &quot;if (TRUE) { # SECRET!!\\n 1:10\\n}&quot;) 如果你想隐藏某些特定行而非R代码中完整的表达式，你必须将x分割成单独的行。你可以考虑使用函数xfun::split_lines()，这样的话钩子函数会变成： x &lt;- xfun::split_lines(x) # 分为单独的行 x &lt;- x[!grepl(&#39;# SECRET!!$&#39;, x)] x &lt;- paste(x, collapse = &#39;\\n&#39;) # 组合成单个字符串 hook_source(x, options) 这个示例向你展示了如何操作源代码字符串，而grepl()当然不是字符串操作的唯一选择。在10.2节中，我们将展示其它可能的选择。 10.2 向源代码中添加行号 在本节中，我们将展示一个定义source钩子的例子，该钩子会将行号作为注释添加到源代码中。例如，对于下面这个代码块： ```{r} if (TRUE) { x &lt;- 1:10 x + 1 } ``` 我们想要得到如下的输出： if (TRUE) { # 1 x &lt;- 1:10 # 2 x + 1 # 3 } # 4 完整的例子如下： --- title: 向源代码中添加行号 --- 我们设置了一个`source`钩子来向源代码中添加行号，行号会出现在每行末尾的注释中。 ```{r, include=FALSE} local({ hook_source &lt;- knitr::knit_hooks$get(&#39;source&#39;) knitr::knit_hooks$set(source = function(x, options) { x &lt;- xfun::split_lines(x) n &lt;- nchar(x, &#39;width&#39;) i &lt;- seq_along(x) # 行号 n &lt;- n + nchar(i) s &lt;- knitr:::v_spaces(max(n) - n) x &lt;- paste(x, s, &#39; # &#39;, i, sep = &#39;&#39;, collapse = &#39;\\n&#39;) hook_source(x, options) }) }) ``` 现在我们可以测试这个新钩子了。编译此文档时，你将在每行末尾的注释中看到行号： ```{r} if (TRUE) { x &lt;- 1:10 x + 1 } ``` 上面这个例子中使用的主要技巧是确定每行注释之前需要的空格数，以便注释可以在右边对齐。该空格数取决于每行代码的宽度，我们将钩子函数中的代码留给读者来理解。需要注意的是，函数knitr:::v_spaces()用于生成指定长度的空格，例如： knitr:::v_spaces(c(1, 3, 6, 0)) ## [1] &quot; &quot; &quot; &quot; &quot; &quot; &quot;&quot; 在实际中，如果想要在源代码中添加行号的话，??节中介绍的方法更好，它的语法更简洁，并且适用于源代码和文本输出块。本节中介绍source钩子的主要目的是展示一种使用自定义函数操作源代码的可能性。 10.3 可滚动的文本输出 在5.2.7节中，我们展示了如何通过CSS来限制代码块和文本输出块的高度。实际上，有一个更简单的方法，可以使用块选项的attr.source和attr.output来将style属性添加到Markdown输出中的分离代码块中（有关这些选项的更多信息，请参阅9.13节）。例如，对于这个带有attr.output选项的代码块： ```{r, attr.output=&#39;style=&quot;max-height: 100px;&quot;&#39;} 1:300 ``` 它的Markdown输出为： ```r 1:300 ``` ```{style=&quot;max-height: 100px;&quot;} ## [1] 1 2 3 4 5 6 7 8 9 10 ## [11] 11 12 13 14 15 16 17 18 19 20 ## ... ... ``` 随后文本输出块将被Pandoc转换为HTML： &lt;pre style=&quot;max-height: 100px;&quot;&gt; &lt;code&gt;## [1] 1 2 3 4 5 6 7 8 9 10 ## [11] 11 12 13 14 15 16 17 18 19 20 ## ... ...&lt;/code&gt; &lt;/pre&gt; 更多有关Pandoc中分离代码块的信息，可参阅其阅读手册：https://pandoc.org/MANUAL.html#fenced-code-blocks. attr.source和attr.output选项使我们能够指定每个代码块的最大高度，但是对应的语法有点笨拙，需要我们更好地理解CSS和Pandoc的Markdown语法。下面我们展示了一个使用自定义块选项max.height来自定义输出钩子的例子，这样你只需要设置块选项，如max.height = \"100px\"而非attr.output = 'style=\"max-height: 100px;\"'。在本例中，我们只操作options参数，而不操作x参数： --- title: 可滚动的代码块 output: html_document: highlight: tango --- 我们设置了一个输出钩子，可以当块选项`max.height`已被设置时，向文本输出添加`style`属性： ```{r, include=FALSE} options(width = 60) local({ hook_output &lt;- knitr::knit_hooks$get(&#39;output&#39;) knitr::knit_hooks$set(output = function(x, options) { if (!is.null(options$max.height)) options$attr.output &lt;- c( options$attr.output, sprintf(&#39;style=&quot;max-height: %s;&quot;&#39;, options$max.height) ) hook_output(x, options) }) }) ``` 如果没有`max.height`，可以看到完整的输出，即： ```{r} 1:100 ``` 现在我们设置`max.height`为`100px`，这样可以在文本输出中看到一个滚动条，因为它的高度大于100px。 ```{r, max.height=&#39;100px&#39;} 1:100 ``` 本质上，`max.height`选项被转换为`attr.output`选项，并且即使`attr.output`选项是存在的，这一转换也是有效的，也就是说，它不会覆盖`attr.output`选项，例如，我们可以通过`.numberLines` 属性在文本输出的左侧显示行号： ```{r, max.height=&#39;100px&#39;, attr.output=&#39;.numberLines&#39;} 1:100 ``` 图10.1展示了代码的输出结果。需要注意的是，在最后一个代码块中使用块选项attr.output时，该选项将不会被max.height覆盖，因为我们将现有的属性与max.height生成的style属性组合在了一起： options$attr.output &lt;- c( options$attr.output, sprintf(&#39;style=&quot;max-height: %s;&quot;&#39;, options$max.height) ) 图 10.1: 一个可滚动文本输出的例子，其高度通过块选项max.height来给定 同样地，source 钩子中也可以使用相似的技巧来限制源代码块的高度。 10.4 截断文本输出 当代码块的文本输出很长时，你可能希望只显示前几行。例如，当输出一个几千行数据框时，显示完整的数据可能没有什么帮助，仅显示前几行可能就足够了。下面我们会重新定义输出钩子，以便我们可以通过自定义块选项out.lines来控制最大行数： # 保存内置的 output 钩子 hook_output = knitr::knit_hooks$get(&quot;output&quot;) # 设置一个新的 output 钩子来截断文本输出 knitr::knit_hooks$set(output = function(x, options) { if (!is.null(n &lt;- options$out.lines)) { x = xfun::split_lines(x) if (length(x) &gt; n) { # 截断文本输出 x = c(head(x, n), &#39;....\\n&#39;) } x = paste(x, collapse = &#39;\\n&#39;) } hook_output(x, options) }) 上述钩子函数的基本思想是，如果文本输出的行数大于块选项out.lines设置的阈值（存储在变量n中），我们只保留前n行，并添加省略号（....）来表示输出被截断。 现在我们可以通过设置块选项out.lines = 4来测试新的输出钩子，你将看到四行输出： print(cars) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 .... 由于我们已经将原始的输出钩子存储在output中，我们可以通过再次调用set()来恢复它： knitr::knit_hooks$set(output = hook_output) 作为进一步的练习，你可以尝试以不同的方式截断输出：给定块选项’ out.lines来确定最大行数，你能在中间而不是末尾截断输出吗？例如，如果设定out.lines = 10，提取前5行和后5行，并在中间添加....的输出是这样的： As an exercise for readers, you may try to truncate the output in a different way: given the chunk option out.lines to determine the maximum number of lines, can you truncate the output in the middle instead of the end? For example, if out.lines = 10, you extract the first and last five lines, and add .... in the middle like this: ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 7 22 .... ## 46 24 70 ## 47 24 92 ## 48 24 93 ## 49 24 120 ## 50 25 85 需要注意的是，输出的最后一行（即钩子函数的参数x）可能是空行，所以可能需要设定c(head(x, n/2), '....', tail(x, n/2 + 1))，其中+ 1将最后的空行也纳入考虑。 10.5 以HTML5格式输出图像 默认情况下，R Markdown的HTML输出中的图包含在标签&lt;p&gt;或&lt;div&gt;下的&lt;img src=\"...\" /&gt;中。下面的例子展示了如何使用HTML5的标签&lt;figure&gt;来显示图像。 --- title: 在标签`&lt;figure&gt;`中输出图像 output: html_document --- 在块选项`options$fig.cap`中给定图像文件路径`x`和图像标题（caption），我们想用如下形式把图像写入HTML5的标签之中： ```html &lt;figure&gt; &lt;img src=&quot;PATH&quot; alt=&quot;CAPTION&quot; /&gt; &lt;figcaption&gt;CAPTION&lt;/figcaption&gt; &lt;/figure&gt; ``` 现在我们重新定义`plot`钩子（仅当输出格式为HTML时）: ```{r} if (knitr::is_html_output()) knitr::knit_hooks$set( plot = function(x, options) { cap &lt;- options$fig.cap # 图像标题 tags &lt;- htmltools::tags as.character(tags$figure( tags$img(src = x, alt = cap), tags$figcaption(cap) )) } ) ``` 代码块中的图像将被放置在`&lt;figure&gt;`标签之中： ```{r, fig.cap=&#39;一个`cars`数据的散点图&#39;} par(mar = c(4.5, 4.5, .2, .2)) plot(cars, pch = 19, col = &#39;red&#39;) ``` 我们可以进一步添加一些CSS样式来让`&lt;figure&gt;`和`&lt;figcaption&gt;`标签“看”起来更好一些（`figure`有虚线边框，图像标题有浅粉色背景）： ```{css, echo=FALSE} figure { border: 2px dashed red; margin: 1em 0; } figcaption { padding: .5em; background: lightpink; font-size: 1.3em; font-variant: small-caps; } ``` 图像的输出如图figure 10.2所示。注意，在这个例子中我们实际上覆盖了默认的plot钩子，而本章的大多数其他例子都是在默认钩子的基础上构建自定义钩子。只有当你确定要忽略默认钩子的一些内置特性时，你才应该完全覆盖默认钩子。例如，在本例中，plot钩子函数没有考虑像out.width = '100%'或fig.show = 'animate'这样的块选项。 图 10.2: 一个在HTML5 figure 标签中的图像 上例展示了在plot钩子中使用图像文件路径x可以进行的操作。如果你所需要的只是自定义图像的样式，则不必使用HTML5标签。通常情况下，默认的plot钩子会以如下的HTML代码输出图像： &lt;div class=&quot;figure&quot;&gt; &lt;img src=&quot;PATH&quot; /&gt; &lt;p class=&quot;caption&quot;&gt;CAPTION&lt;/p&gt; &lt;/div&gt; 所以你可以仅为div.figure和p.caption定义css规则。 "],["knitr-misc.html", "第 11 章 其它使用 knitr 的小技巧 11.1 重复使用代码块 11.2 在创建对象之前使用它 (*) 11.3 提前退出编译 11.4 生成一个图像并在其他地方显示 11.5 修改前一个代码块中的图像 11.6 保存一组块选项并重复使用它们 (*) 11.7 使用 knitr::knit_expand() 来生成 Rmd 源代码 11.8 允许代码块中的标签重复 Allow duplicate labels in code chunks (*) 11.9 一个更透明的缓存机制", " 第 11 章 其它使用 knitr 的小技巧 除了块选项（参见第9章）、输出钩子（参见第10章）和块钩子（参见第??章）之外，在knitr中还有很多有用的函数和技巧。我们将在本章中介绍这些技巧，例如重复使用代码块、提前退出编译、在自定义位置显示图像等等。 11.1 重复使用代码块 哪怕不用复制黏贴，也可以在源文档中自由地重复使用代码块。这其中的关键点在于标记代码块，从而在其它地方用标签的形式引用它们。本节将介绍三种重复使用代码块的方法。 11.1.1 将一个块嵌入到另一个块中 (*) 将代码块的标签用&lt;&lt;&gt;&gt;括起来，则可以将该代码块嵌入到另一个代码块中。之后knitr将自动将其在实际代码中扩展为&lt;&lt;label&gt;&gt;。例如，可以这样创建一个R函数： 我们定义了一个函数，可以将华氏度转为摄氏度。 ```{r, f2c} F2C &lt;- function(x) { &lt;&lt;check-arg&gt;&gt; &lt;&lt;convert&gt;&gt; } ``` 首先，检查输入值是否为数字： ```{r, check-arg, eval=FALSE} if (!is.numeric(x)) stop(&quot;The input must be numeric!&quot;) ``` 然后进行转换： ```{r, convert, eval=FALSE} (x - 32) * 5/ 9 ``` 这是基于唐纳德·克努特（Donald Knuth）提出的文学编程的主要思想之一。这种技术的优点在于，你可以将（复杂的）代码分割成更小的部分，将每个部分写入单独的代码块中，并使用文字叙述来解释它们。所有的部分都可以被放入要执行的主代码块中。 在上面的例子中，第一个代码块（标签为f2c）将变成： ```{r, f2c} F2C &lt;- function(x) { if (!is.numeric(x)) stop(&quot;The input must be numeric!&quot;) (x - 32) * 5/ 9 } ``` 一个代码块中可以嵌入任意数量的其他代码块，并且嵌入也可以是递归的。例如，可以将块A嵌入到块B中，将块B嵌入到块C中，这样块C将借由块B包含块A中的代码。 另外，标记符&lt;&lt;label&gt;&gt;不必单独写成一行，它可以嵌入到代码块的任何地方。 11.1.2 在另一个块中使用相同的块标签 如果你想要重复多次使用完全相同的代码块，则可以用一个标签来定义块，并使用相同的标签创建更多的代码块，但需要保留块的内容为空，例如： 下面是一个没有被运行的代码块： ```{r, chunk-one, eval=FALSE} 1 + 1 2 + 2 ``` 现在我们运行该代码块： ```{r, chunk-one, eval=TRUE} ``` 在上面的例子中，我们使用了两次块标签chunk-one，第二个块只是重复使用了第一个块的代码。 我们建议你不要使用此方法多次（多于一次）运行代码块来生成图像或其他文件，因为从后面的块创建的图像文件可能会覆盖前一个块创建的文件。如果只有一个块使用块选项eval = TRUE，而所有其他块使用eval = FALSE的话是可以的。 11.1.3 使用引用标签 (*) 块选项ref.label利用一个由块标签组成的向量来检索这些块的内容。例如在下例中，标签为chunk-a的代码块是chunk-c和chunk-b的组合: ```{r chunk-a, ref.label=c(&#39;chunk-c&#39;, &#39;chunk-b&#39;)} ``` ```{r chunk-b} # 这是块 b 1 + 1 ``` ```{r chunk-c} # 这是块 c 2 + 2 ``` 换句话说，chunk-a实际上是这样的： ```{r chunk-a} # 这是块 c 2 + 2 # 这是块 b 1 + 1 ``` 块选项ref.label提供了一种非常灵活的方式，可以在文档中重新组织代码块，而无需采用剪切粘贴的方式。需要注意的是，被引用的代码块在使用ref.label的代码块之前还是之后并不重要，前面的代码块可以引用后面的代码块。 这个块选项的相关应用可参见??节。 11.2 在创建对象之前使用它 (*) 一个knitr文档中的所有代码，包括代码块和行内R表达式中的代码，从开始到结束都是按先后顺序执行的。从理论上讲，在给变量赋值之前不能使用它。但是，在某些情况下，我们可能想在文档前面提到一个变量的值。例如，通常在文章的摘要中需要显示结果，但结果实际上是在文档的后面计算的。下面的例子说明了这个想法，但无法编译： --- 题目：一个重要的报告 摘要： &gt; 在本文的分析中，`x` 的平均值是 `r mx`... --- 我们在下面的块中创建对象`mx`： ```{r} x &lt;- 1:100 mx &lt;- mean(x) ``` 要解决这个问题，对象的值必须先保存在某个地方，并在下一次编译文档时加载。需要注意的是，这一操作意味着文档至少需要被编译两次。下面的例子介绍了一章可能的解决方案，即使用saveRDS()函数： ```{r, include=FALSE} mx &lt;- if (file.exists(&#39;mean.rds&#39;)) { readRDS(&#39;mean.rds&#39;) } else { &quot;The value of `mx` is not available yet&quot; } ``` --- 题目：一个重要的报告 摘要： &gt; 在本文的分析中，`x` 的平均值是 `r mx`... --- 我们在下面的块中创建对象`mx`： ```{r} x &lt;- 1:100 mx &lt;- mean(x) saveRDS(mx, &#39;mean.rds&#39;) ``` 第一次编译本文档时，你将在摘要中看到短语 “The value of mx is not available yet”。之后当你再次编译它时，你将会看到mx的值。 函数knitr::load_cache()是一个替代的解决方案，它允许你在特定的代码块已经被缓存了之后从该代码块加载对象的值。这个想法与上面的例子类似，但它将减少手动保存和加载对象的工作，因为对象会自动保存到缓存数据库，只需要通过load_cache()加载它即可。下面是简化的例子： --- 题目：一个重要的报告 摘要： &gt; 在本文的分析中，`x` 的平均值是 `r knitr::load_cache(&#39;mean-x&#39;, &#39;mx&#39;)`. --- 我们在下面的块中创建对象`mx`： ```{r mean-x, cache=TRUE} x &lt;- 1:100 mx &lt;- mean(x) ``` 在这个例子中，我们给R代码块添加了一个块标签mean-x（被传递给load_cache()函数），并使用块选项cache = TRUE来缓存它。此代码块中的所有对象都将被保存到缓存数据库中。同样的，你必须至少编译该文档两次，这样才能正确地从缓存数据库加载对象mx。如果mx的值今后不会被更改，则不需要再次编译该文档。 如果在load_cache()的第二个参数中没有指定对象名，整个缓存数据库将被加载到当前环境中。然后，你可以从缓存数据库中调用这些本应在后续的文档中被创建的对象，例如： knitr::load_cache(&#39;mean-x&#39;) x # 对象 `x` mx # 对象 `mx` 11.3 提前退出编译 有时，我们可能希望提前退出编译，而不是在文档的末尾退出。例如，我们可能正在进行一些分析，并且只希望分享结果的前半部分，或者可能文档末尾的一些代码尚未完成。在这些情况下，我们可以考虑在一个代码块中使用knit_exit()函数，它将在该代码块之后结束编译过程。 下面是一个简单的例子，我们有一个非常简单的块，并紧跟着有一个更耗时的块： ```{r} 1 + 1 knitr::knit_exit() ``` 在输出中你将只会看到上面的内容。 ```{r} Sys.sleep(100) ``` 一般情况下，你需要等待100秒来编译整个文档，但由于我们调用了knit_exit()，文档的剩余部分将不会被编译。 11.4 生成一个图像并在其他地方显示 通常情况下，由代码块中生成的图像会显示在代码块下面，但其实可以选择在其他地方显示它们，还可以在代码块中隐藏它们，例如： 我们在这个代码块中生成了一个图像，但是没有显示出来： ```{r cars-plot, dev=&#39;png&#39;, fig.show=&#39;hide&#39;} plot(cars) ``` 在另一段之后，我们介绍了该图像： ![一张好看的图](`r knitr::fig_chunk(&#39;cars-plot&#39;, &#39;png&#39;)`) 在代码块中，我们使用了块选项fig.show='hide'来把图像暂时隐藏起来。然后在另一段中，我们调用函数knitr::fig_chunk()来检索得到绘图文件的路径，例如test_files/figure-html/cars-plot-1.png。你需要将块标签和图像设备名称传递给fig_chunk()，以便它更好地得到图像文件路径。 在https://stackoverflow.com/a/46305297/559676上可以看到fig_chunk()在一个blogdown网站的应用。这个函数适用于任何R Markdown的输出格式，并且它对于在幻灯片上显示图像特别有用，因为幻灯片页上的屏幕空间通常是有限的，可以在一张幻灯片上展示代码，然后在另一张幻灯片上展示图像。 11.5 修改前一个代码块中的图像 在默认情况的下，knitr会打开一个新的图像设备来记录每个新代码块产生的图像。这就带来了一个问题：不能轻易地修改之前代码块产生的图像，因为之前的图像设备已经关闭了。这对于基础的R图形通常是有问题的（但不会影响从ggplot2 (R-ggplot2?)创建的网格图像，因为其可以被保存为R对象）。例如，如果我们在一个代码块中绘制一个图，并在后面的代码块中添加一条线，R将发出一个错误信号，表示还没有创建这个图，因此不能添加线。 如果想让图像设备对所有代码块均保持打开的状态，可以在文档的开头设置一个knitr包的选项： knitr::opts_knit$set(global.device = TRUE) 需要注意的是，这里使用的是opts_knit而非更常用的opts_chunk。相关例子可参见Stack Overflow的帖子https://stackoverflow.com/q/17502050。而当你不再需要这个全局的图像设备时，可以将该选项设置为FALSE。下面是一个完整的例子： --- title: &quot;使用全局图像设备记录图像&quot; --- 首先，开启全局图像设备： ```{r, include=FALSE} knitr::opts_knit$set(global.device = TRUE) ``` 画一张图： ```{r} par(mar = c(4, 4, 0.1, 0.1)) plot(cars) ``` 给之前代码块生成的图添加一条线： ```{r} fit &lt;- lm(dist ~ speed, data = cars) abline(fit) ``` 不再使用全局图像设备了： ```{r, include=FALSE} knitr::opts_knit$set(global.device = FALSE) ``` 画另一张图： ```{r} plot(pressure, type = &#39;b&#39;) ``` 11.6 保存一组块选项并重复使用它们 (*) 如果你经常需要使用一些块选项，不妨把它们保存为一个组，然后只使用组的名称来重复使用它们。这可以通过knitr::opts_template$set(name = list(options))来实现，之后可以使用opts.label来引用组名，从而实现重复使用。例如： ```{r, setup, include=FALSE} knitr::opts_template$set(fullwidth = list( fig.width = 10, fig.height = 6, fig.retina = 2, out.width = &#39;100%&#39; )) ``` ```{r, opts.label=&#39;fullwidth&#39;} plot(cars) ``` 在设定opts.label = 'fullwidth'时， knitr将从knitr::opts_template中读取块选项，并将它们应用到当前的块中，这样可以节省一些打字的工作量。如果一个块选项要在文档中全局使用，则应该考虑全局地设置它（参见第9章）。 你还可以覆盖从opts.label中读取的选项，例如，如果你在下面的块中设置fig.height = 7，则实际的fig.height将变为7而非6，从而可以对单个块进行调整。 ```{r, opts.label=&#39;fullwidth&#39;, fig.height=7} plot(cars) ``` 事实上，你可以保存任意数量的分组选项，例如knitr::opts_template$set(group1 = list(...), group2 = list(...))。 11.7 使用 knitr::knit_expand() 来生成 Rmd 源代码 函数knitr::knit_expand()可以将{{ }}中的表达式“扩展”为它的值（默认），例如， knitr::knit_expand(text = &quot;The value of `pi` is {{pi}}.&quot;) ## [1] &quot;The value of `pi` is 3.14159265358979.&quot; knitr::knit_expand( text = &quot;The value of `a` is {{a}}, so `a + 1` is {{a+1}}.&quot;, a = round(rnorm(1), 4) ) ## [1] &quot;The value of `a` is 0.338, so `a + 1` is 1.338.&quot; 这意味着，如果你有一个Rmd文档，其中包含了{{ }}中的一些动态部分，那么可以在该文档上应用knit_expand()，然后调用knit()来编译它。例如，下面是一个名为template.Rmd的模板文档： # 在 {{i}} 上进行回归 ```{r lm-{{i}}} lm(mpg ~ {{i}}, data = mtcars) ``` 我们可以用mpg来对mtcars数据集中的所有其他变量逐个建立线性回归模型： ```{r, echo=FALSE, results=&#39;asis&#39;} src = lapply(setdiff(names(mtcars), &#39;mpg&#39;), function(i) { knitr::knit_expand(&#39;template.Rmd&#39;) }) res = knitr::knit_child(text = unlist(src), quiet = TRUE) cat(res, sep = &#39;\\n&#39;) ``` 如果理解这个例子有难度，可参阅9.11节，以了解块选项results = 'asis'，以及??节来了解knitr::knit_child()的用法。 11.8 允许代码块中的标签重复 Allow duplicate labels in code chunks (*) 默认情况下，knitr不允许在文档中重复代码块标签。在编译文档时，重复的标签将导致错误。这种情况常见于在文档中复制和粘贴代码块的时候，会产生这样的错误信息： processing file: myfile.Rmd Error in parse_block(g[-1], g[1], params.src, markdown_mode) : Duplicate chunk label &#39;cars&#39; Calls: &lt;Anonymous&gt; ... process_file -&gt; split_file -&gt; lapply -&gt; FUN -&gt; parse_block Execution halted 然而，在某些情况下，我们希望允许标签可以重复。例如，如果我们有一个母文档parent.Rmd，在其中我们会多次编译子文档，下面的代码会运行失败： # 设置 settings = list(...) # 第一次运行 knit_child(&#39;useful_analysis.Rmd&#39;) # 重新设置 settings = list(...) # 再次运行 knit_child(&#39;useful_analysis.Rmd&#39;) 在这个场景中，我们可以通过在编译子文档之前在R中设置这个全局选项来允许标签可重复： options(knitr.duplicate.label = &#39;allow&#39;) 如果你想在母文档而不是子文档中允许标签可重复，则必须在knitr::knit()被调用之前设置这个选项。一种可能的方法是在~/.Rprofile中设置这个选项（更多信息可参见帮助页面?Rprofile）。 设置此选项时需要很谨慎，与大多数的报错一样，它们的存在是有原因的。允许重复的块可能会在图像和交叉引用方面产生静默问题（silent problem）。例如，理论上，如果两个代码块具有相同的标签，并且两个代码块都生成图像，那么它们的图像文件将互相覆盖（并不会产生错误或警告消息），因为图像的文件名是由块标签决定的。使用选项knitr.duplicate.label = \"allow\"时， knitr将通过添加数字后缀来静默地改变重复标签。例如，对于两个代码块： ```{r, test} plot(1:10) ``` ```{r, test} plot(10:1) ``` 第二个标签将被静默地更改为test-1，这将避免覆盖由标签test的块产生的图像，但这也使得块标签不可被预知，所以在交叉引用图像时可能会产生困难（参见 ??节），因为交叉引用也是基于块标签的。 11.9 一个更透明的缓存机制 如果你觉得在9.4节中介绍的knitr的缓存机过于复杂（确实如此!），可以考虑使用基于函数xfun::cache_rds()的一个更简单的缓存机制，例如： xfun::cache_rds({ # 在这里编写你的耗时代码 }) 关于knitr缓存，其棘手之处在于如何决定何时使缓存失效，而使用xfun::cache_rds()则要清楚得多：第一次将R表达式传递给这个函数时，它会计算表达式并将结果保存到.rds文件中；下次再次运行cache_rds()时，它会读取.rds的文件，并立即返回结果，而不再次计算表达式。使缓存无效的最明显的方法是删除.rds的文件。如果不想手动删除它，则可以用参数rerun = TRUE来调用xfun::cache_rds()。 当xfun::cache_rds() 在knitr源文档的一个代码块中被调用时，.rds文件的路径由块选项cache.path和块标签决定。例如，对于在Rmd文档input.Rmd中带有块标签foo的代码块： ```{r, foo} res &lt;- xfun::cache_rds({ Sys.sleep(3) 1:10 }) ``` .rds文件的路径格式为input_cache/FORMAT/foo_HASH.rds，其中FORMAT是Pandoc输出格式名称（例如html或latex）， HASH是一个MD5哈希，包含了32个十六进制数字（a-f10和0-9），例如input_cache/html/foo_7a3f22c4309d400eff95de0e8bddac71.rds。 如帮助页面?xfun::cache_rds所述，通常在两种的情况下可能想要使缓存失效：1）待求值表达式中的代码发生了变化；2）代码使用了一个外部变量，并且该变量的值已经改变。接下来，我们将解释这两种情况下缓存是如何失效的，以及如何将缓存的多个副本保存到对应于不同版本的代码中。 11.9.1 通过更改表达式中的代码使缓存失效 当你改变cache_rds()中的代码时（例如，从cache_rds({x + 1})改为cache_rds({x + 2})），缓存将自动失效，表达式将被重新计算。但是，需要注意的是，空格或注释的变化并不重要，或者一般来说，只要更改不影响已解析的表达式，缓存就不会失效。例如，下面传递给cache_rds()的两个表达式在本质上是相同的： res &lt;- xfun::cache_rds({ Sys.sleep(3); x&lt;-1:10; # 分号不影响 x+1; }) res &lt;- xfun::cache_rds({ Sys.sleep(3) x &lt;- 1:10 # 一个注释 x + 1 # 可以随意修改空格部分 }) 因此，如果对第一个表达式执行cache_rds()，那么第二个表达式将能够调用缓存的结果。这一特性非常有用，因为其允许在代码中进行修饰性更改，而不会使缓存失效。 如果不确定两个版本的代码是否相等，则可以尝试下面的parse_code()函数： parse_code &lt;- function(expr) { deparse(substitute(expr)) } # 空格或分号不影响 parse_code({x+1}) ## [1] &quot;{&quot; &quot; x + 1&quot; &quot;}&quot; parse_code({ x + 1; }) ## [1] &quot;{&quot; &quot; x + 1&quot; &quot;}&quot; # 左箭头和右箭头是等价的 identical(parse_code({x &lt;- 1}), parse_code({1 -&gt; x})) ## [1] TRUE 11.9.2 通过更改全局变量使缓存失效 通常情况下，表达式中有两种类型的变量：全局变量和局部变量。全局变量是在表达式外部创建的，局部变量则是在表达式内部创建的。如果表达式中全局变量的值发生了变化，那么缓存的结果和再次运行的结果之间可能会产生差异。例如，在下面的表达式中，如果y发生了变化，你可能想要使缓存失效并重新运行表达式，否则你仍然会得到根据y之前的值计算得到的结果： y &lt;- 2 res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }) 如果要使缓存当y发生变化时失效，你可以则需要通过hash参数，让cache_rds()在决定缓存是否应该失效时知道需要考虑y： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }, hash = list(y)) 当hash参数的值改变时，缓存文件名中的32位哈希值（如前所述）会相应地改变，导致缓存失效。这提供了一种方法来指定缓存与其他R对象的依赖关系。例如，如果想要使缓存依赖于R的版本，可以这样指定依赖： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }, hash = list(y, getRversion())) 或者，如果你想让缓存依赖于数据文件最后一次修改的时间，则可这样做： res &lt;- xfun::cache_rds({ x &lt;- read.csv(&quot;data.csv&quot;) x[[1]] + y }, hash = list(y, file.mtime(&quot;data.csv&quot;))) 如果你不想为hash参数提供全局变量的列表，则可以尝试hash = \"auto\"，它将使cache_rds()自动找出所有的全局变量，并将它们作为hash参数的值，例如： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y + z # y 和 z 是全局变量 }, hash = &quot;auto&quot;) 这等价于： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y + z # y and z are global variables }, hash = list(y = y, z = z)) 当hash = \"auto\"时，全局变量由codetools::findGlobals()识别，这可能不是完全可靠的，所以如果你想要完全确定哪些变量可以使缓存失效，我们建议你在hash参数中亲自给定变量列表。 11.9.3 保留缓存的多个副本 由于缓存通常用于非常耗时的代码，在使其失效时应保守一些。你可能会因过早地或主动地使缓存失效而后悔，因为如果你再次需要一个旧版本的缓存，则将不得不等待很长的时间才能重新完成计算。 若将cache_rds()中的clean参数设置为FALSE，则其将允许你保留旧的缓存副本。你也可以设置全局R选项options(xfun.cache_rds.clean = FALSE)来使其成为文档的默认行为。在默认情况下，clean = TRUE和cache_rds()每次都会尝试删除旧的缓存。如果你还在进行代码测试，那么设置clean = FALSE会很有用。例如，可以缓存一个线性模型的两个版本： model &lt;- xfun::cache_rds({ lm(dist ~ speed, data = cars) }, clean = FALSE) model &lt;- xfun::cache_rds({ lm(dist ~ speed + I(speed^2), data = cars) }, clean = FALSE) 在决定使用哪个模型之后，你可以再次设置clean = TRUE，或者删除clean参数（默认为TRUE）。 11.9.4 与knitr的缓存比较 你可能想知道什么时候使用knitr的缓存（例如，设置块选项cache = TRUE），什么时候在knitr源文档中使用xfun::cache_rds()。后者最大的缺点是它不缓存副产物（而只缓存表达式的值），而knitr却可以。一些副产物可能是有用的，例如打印的输出或图像。例如，在下面的代码中，当使用cache_rds()加载缓存时，文本输出和图像将会丢失，只会返回1:10： xfun::cache_rds({ print(&quot;Hello world!&quot;) plot(cars) 1:10 }) 相比之下，对于设定选项为cache = TRUE的代码块，所有的内容都将被缓存： ```{r, cache=TRUE} print(&quot;Hello world!&quot;) plot(cars) 1:10 ``` knitr的缓存最大的缺点（同时也是用户最常抱怨的）是缓存可能会在不经意间失效，因为缓存由太多的因素所决定。例如，任何块选项的改变都会使缓存失效11，但有些块选项可能与计算无关。在下面的代码块中，改变块选项fig.width = 6到fig.width = 10不应该使缓存失效，但事实上它会： ```{r, cache=TRUE, fig.width=6} # 这个块没有生成图像 x &lt;- rnorm(1000) mean(x) ``` 实际上，knitr的缓存非常强大且灵活，它的行为可以通过多种方式进行调整。它的作者也经常怀疑是否值得介绍这些不太为人所知的特性，因为可能会导致使用者花更多的时间来学习和理解缓存如何工作，而非运行实际的代码。 在不清楚用哪个的情况下，xfun::cache_rds()是缓存计算结果的通用方法，它可以在任何地方使用，而knitr的缓存只能在knitr文档中使用。 原文为a-z。↩︎ 这是默认的行为，你也可以进行调整。如果想了解如何使缓存更精细，而非所有块选项都会影响缓存，请参阅https://yihui.org/knitr/demo/cache/。↩︎ "],["other-languages.html", "第 12 章 与其他语言的结合 12.1 注册自定义语言引擎（*） 12.2 运行 Python 代码并与 Python 交互 12.3 通过 asis 引擎有条件地执行内容 12.4 执行 Shell 脚本 12.5 用 D3 可视化 12.6 通过 cat 引擎将块内容写入文件 12.7 运行 SAS 代码 12.8 运行 Stata 代码 12.9 用渐近线 Asymptote 创建图形 12.10 使用 Sass/SCSS 构建 HTML 页面风格", " 第 12 章 与其他语言的结合 除 R 语言外， knitr 软件包在 R Markdown 中还支持许多其他的语言。在三个反引号后的花括号中的第一个单词表示语言名称。 例如， ```{r} 中的小 r 表示该代码块为 R 代码块，而 ```{python} 是指该代码块为 Python 代码块。本章我们会介绍一些你可能不熟悉的语言。 在 knitr 中，每种语言都通过语言引擎得到支持。语言引擎本质上是一些函数，它们以源代码和块的选项作为输入，最后输出一个字符串。并通过 knitr::knit_engines 进行管理。你可以使用以下方式检查现有引擎： names(knitr::knit_engines$get()) ## [1] &quot;awk&quot; &quot;bash&quot; &quot;coffee&quot; &quot;gawk&quot; &quot;groovy&quot; &quot;haskell&quot; ## [7] &quot;lein&quot; &quot;mysql&quot; &quot;node&quot; &quot;octave&quot; &quot;perl&quot; &quot;psql&quot; ## [13] &quot;Rscript&quot; &quot;ruby&quot; &quot;sas&quot; &quot;scala&quot; &quot;sed&quot; &quot;sh&quot; ## [19] &quot;stata&quot; &quot;zsh&quot; &quot;highlight&quot; &quot;Rcpp&quot; &quot;tikz&quot; &quot;dot&quot; ## [25] &quot;c&quot; &quot;cc&quot; &quot;fortran&quot; &quot;fortran95&quot; &quot;asy&quot; &quot;cat&quot; ## [31] &quot;asis&quot; &quot;stan&quot; &quot;block&quot; &quot;block2&quot; &quot;js&quot; &quot;css&quot; ## [37] &quot;sql&quot; &quot;go&quot; &quot;python&quot; &quot;julia&quot; &quot;sass&quot; &quot;scss&quot; ## [43] &quot;R&quot; &quot;bslib&quot; 目前，大多数非r语言的代码块都是独立执行的。例如，同一文档中的所有 bash 代码块都在各自的会话中单独执行，因此后面的 bash 代码块不能使用在先前 bash 代码块中创建的变量，更改后的工作目录(通过 cd )不会跨不同的bash块持久存在。只有 R、Python 和 Julia 代码块在同一个会话中执行。请注意，所有的R代码块都在同一个R会话中执行，所有的Python代码块都在同一个Python会话中执行，等等。R会话和Python会话是两个不同的会话，但是可以从另一个会话访问或操作一个会话的对象(参见15.2节)。 R Markdown权威指南 (Xie, Allaire, and Grolemund 2018) 的2.7节 展示了如何在R Markdown中使用Python, Shell, SQL, Rcpp, Stan, JavaScript, CSS, Julia, C，和Fortran代码。在本章中，我们将展示更多的语言引擎，你可以在下面的库中找到更多的例子： https://github.com/yihui/knitr-examples （查找包含单词引擎的文件名）。 首先，让我们通过注册一个自定义语言引擎来揭示语言引擎是如何工作的。 12.1 注册自定义语言引擎（*） 你可以通过使用 knitr::knit engines$set() 方法注册一个自定义语言引擎。它接受一个函数作为输入，例如： 这样就已经注册了 foo 引擎，现在你可以使用以 ```{foo} 开头的代码块了。 这个引擎函数中有一个 options 参数，它是代码块的块选项列表。你可以在 options$code 中以字符向量的形式访问块的源代码。例如，对于代码块： ```{foo} 1 + 1 2 + 2 ``` options的代码元素是一个字符向量 c('1 + 1', '2 + 2')。 语言引擎实际上不必处理计算机语言，但可以处理代码块中的任何文本。首先，我们展示一个简单的引擎示例，该引擎将代码块的内容转换为大写： knitr::knit_engines$set(upper = function(options) { code &lt;- paste(options$code, collapse = &#39;\\n&#39;) if (options$eval) toupper(code) else code }) 关键是我们将 toupper 函数应用于代码，并以单个字符串的形式返回结果(通过\\n连接所有代码行)。注意toupper()仅在chunk选项 eval = TRUE 时才应用，否则返回原始字符串。这向您展示了如何在引擎函数中使用 eval 之类的块选项。类似地，你可以考虑在函数体中添加 if (options$results == 'hide') return() 来隐藏chunk选项时的输出 results = 'hide' 。下面是一个使用 upper 引擎及其输出的示例块 ```{upper} Hello, **knitr** engines! ``` HELLO, KNITR ENGINES! 接下来，我们展示一个名为 py 的另一种 python 引擎的示例12。这个引擎是通过R函数 system2() 调用 python 命令来实现的： knitr::knit_engines$set(py = function(options) { code &lt;- paste(options$code, collapse = &#39;\\n&#39;) out &lt;- system2( &#39;python&#39;, c(&#39;-c&#39;, shQuote(code)), stdout = TRUE ) knitr::engine_output(options, code, out) }) 为了充分理解以上引擎的功能，你需要了解以下内容： 给定 Python 代码作为字符串（上述函数中的代码），我们可以通过命令行调用 python -c 'code' 执行代码。 那就是 system2() 所做的。 我们通过在 system2() 中指定 stdout = TRUE 来收集（文本）输出。 你可以将块选项、源代码和文本输出传递给函数 knitr::engine_output() 以生成最终输出。这个函数处理常见的块选项，比如 echo = FALSE 和 results = 'hide'，所以你不需要注意这些情况。 knitr 中的许多语言引擎都是这样定义的(例如，使用 system2() 来执行与语言对应的命令)。如果你对技术细节感兴趣，你可以在这里的R源代码中查看大多数语言引擎的源代码 https://github.com/yihui/knitr/blob/master/R/engine.R。 现在我们可以使用新的引擎 py，例如： ```{py} print(1 + 1) ``` ## 2 如果你觉得你的版本比现有的更好你甚至可以通过 knitr::knit_engines$set() 重写现有的语言引擎。但是，通常我们不建议你这样做，因为这可能会让熟悉现有引擎的用户感到惊讶，但我们无论如何都想让你意识到这种可能性。 12.2 运行 Python 代码并与 Python 交互 我们知道你喜欢 Python，所以让我们把它说清楚： R Markdown 和 knitr 确实支持 Python。 要将 Python 代码块添加到R Markdown文档中，可以在块的头部变为```{python}，例如： ```{python} print(&quot;Hello Python!&quot;) ``` 你可以像往常一样在chunk头中添加chunk选项，比如 echo = FALSE 或 eval = FALSE ，并且也支持使用Python中的 matplotlib 包绘图。 R Markdown 和 knitr 中的Python支持是 reticulate 包 (Ushey, Allaire, and Tang 2020)，这个包的一个重要特性是它允许Python和R之间的双向通信。例如，你可以在R会话中通过reticulate包中的py对象访问或创建Python变量： ```{r, setup} library(reticulate) ``` Create a variable `x` in the Python session: ```{python} x = [1, 2, 3] ``` Access the Python variable `x` in an R code chunk: ```{r} py$x ``` Create a new variable `y` in the Python session using R, and pass a data frame to `y`: ```{r} py$y &lt;- head(cars) ``` Print the variable `y` in Python: ```{python} print(y) ``` 有关 reticulate 的更多信息，您可以在下面查看它的文档 https://rstudio.github.io/reticulate/。 12.3 通过 asis 引擎有条件地执行内容 正如其名， asis 引擎按原样写出块内容。使用此引擎的优点是，你可以有条件地包含一些内容，块内容的显示由块选项 echo 决定。当 echo = FALSE 时，数据块将被隐藏。下面是一个简单的例子： ```{r} getRandomNumber &lt;- function() { sample(1:6, 1) } ``` ```{asis, echo = getRandomNumber() == 4} According to https://xkcd.com/221/, we just generated a **true** random number! ``` 只有当条件 getRandomNumber() == 4 (随机)为真时， asis 块中的文本才会显示。 12.4 执行 Shell 脚本 你可以根据你的喜好，使用 bash、 sh 或 zsh 任何一种引擎运行Shell脚本。下面是一个带有 chunk 头 ```{bash} 的 bash 示例： ls *.Rmd | head -n 5 ## [1] &quot;01-intro.Rmd&quot; &quot;02-installation.Rmd&quot; &quot;03-basics.Rmd&quot; ## [4] &quot;06-HTML-document.Rmd&quot; &quot;07-PDF-document.Rmd&quot; 注意，bash是用 R 函数 system2() 调用的。它将忽略配置文件，例如 ~/.bash_profile 和 ~/.bash_login，其中可能定义了命令别名或修改过的环境变量(如 PATH 变量)。如果你想要这些配置文件像你使用终端时一样被执行，你可以通过引擎将参数 -l 传递给 bash。例如： ```{bash, engine.opts=&#39;-l&#39;} echo $PATH ``` 如果你想对所有 bash 块全局启用 -l 参数，你可以在文档开头的global chunk选项中设置为： knitr::opts_chunk$set(engine.opts = list(bash = &#39;-l&#39;)) 还可以将其他参数作为字符向量提供给chunk选项engine.opts，从而传递给bash。 12.5 用 D3 可视化 r2d3包 (Strayer, Luraschi, and Allaire 2020) (Luraschi和Allaire 2018)是 D3 可视化的接口。这个包可以用于 R Markdown 文档以及其他应用程序(如 Shiny)。要在 R Markdown 中使用它，您可以在代码块中调用它的函数 r2d3()，或者使用它的 d3 引擎。后者要求你理解 D3 库和 JavaScript，这超出了本书的范围，我们将把它们留给读者去学习。下面是一个使用 d3 引擎绘制柱状图的例子： --- title: Generate a chart with D3 output: html_document --- First, load the package **r2d3** to set up the `d3` engine for **knitr** automatically: ```{r setup} library(r2d3) ``` Now we can generate data in R, pass it to D3, and draw the chart: ```{d3, data=runif(30), options=list(color=&#39;steelblue&#39;)} svg.selectAll(&#39;rect&#39;) .data(data) .enter() .append(&#39;rect&#39;) .attr(&#39;width&#39;, function(d) { return d * 672; }) .attr(&#39;height&#39;, &#39;10px&#39;) .attr(&#39;y&#39;, function(d, i) { return i * 16; }) .attr(&#39;fill&#39;, options.color); ``` 12.6 通过 cat 引擎将块内容写入文件 有时将代码块的内容写入外部文件，然后在其他代码块中使用此文件可能会很有用。当然，您可以通过 writeLines() 等 R 函数来实现这一点，但问题是，当内容相对较长或包含特殊字符时，传递给 writeLines() 的字符串可能看起来很笨拙。下面是将长字符串写入文件 my-file.txt 的示例： writeLines(&quot;This is a long character string. It has multiple lines. Remember to escape double quotes \\&quot;\\&quot;, but &#39;single quotes&#39; are OK. I hope you not to lose your sanity when thinking about how many backslashes you need, e.g., is it &#39;\\t&#39; or &#39;\\\\t&#39; or &#39;\\\\\\\\t&#39;?&quot;, con = &quot;my-file.txt&quot;) 自R 4.0.0以来，这个问题已经大大缓解了，因为R开始支持 r\"( )\" 中的原始字符串(参见帮助页面 ?Quotes)，而且你不需要记住所有关于特殊字符的规则。即使使用原始字符串，在代码块中显式地将长字符串写入文件仍然会让读者分心。 knitr 中的 cat 引擎为你提供了一种在代码块中呈现文本内容或将其写入外部文件的方法，而无需考虑有关R字符串的所有规则（例如，当需要字面上的反斜杠时，你需要双反斜杠）。 要将块内容写入文件，请在块选项 engine.opts 中指定文件路径，例如 engine.opts = list(file = 'path/to/file')。在引擎盖下，在 engine.opts 中指定的值列表将传递给该函数 在引擎盖之下，engine.opts 中指定的值列表将传递给函数base::cat() 并且 file 是 base::cat() 的参数之一。 接下来，我们将提供三个示例来说明 cat 引擎的用法。 12.6.1 写入 CSS 文件 如7.3节所示，你可以在 Rmd 文档中嵌入一个 css 代码块，以使用 CSS 样式化元素。另一种方法是通过一些 R Markdown 输出格式(如，html_document)的 CSS 选项为 Pandoc 提供一个定制的 CSS 文件。 cat 引擎可以用来从 Rmd 编写这个 CSS 文件。 下面的例子展示了如何从文档中的块生成 custom.css 文件，并将文件路径传递给 html_document 格式的 css 选项。 --- title: &quot;Create a CSS file from a code chunk&quot; output: html_document: css: custom.css --- The chunk below will be written to `custom.css`, which will be used during the Pandoc conversion. ```{cat, engine.opts = list(file = &quot;custom.css&quot;)} h2 { color: blue; } ``` ## And this title will blue css 代码块方法与此方法之间的唯一区别是，前一种方法将 CSS 代码写在输出文档的 &lt;body&gt; 标记内的位置（即，在代码块的位置），并且将 CSS 代码写在输出文档的 &lt;body&gt; 标记内。 后一种方法将 CSS 写入输出文档的 &lt;body&gt; 区域。输出文档中不会有任何实际的视觉差异。 12.6.2 在序言中包含 LaTeX 代码 在6.1节中，我们介绍了如何将 LaTeX 代码添加到序言中，这需要一个外部 .tex 文件。也可以从 Rmd 生成此文件，这是一个示例： --- title: &quot;Create a .tex file from a chunk&quot; author: &quot;Jane Doe&quot; classoption: twoside output: pdf_document: includes: in_header: preamble.tex --- # How it works Write a code chunk to a file `preamble.tex` to define the header and footer of the PDF output document: ```{cat, engine.opts=list(file = &#39;preamble.tex&#39;)} \\usepackage{fancyhdr} \\usepackage{lipsum} \\pagestyle{fancy} \\fancyhead[CO,CE]{This is fancy header} \\fancyfoot[CO,CE]{And this is a fancy footer} \\fancyfoot[LE,RO]{\\thepage} \\fancypagestyle{plain}{\\pagestyle{fancy}} ``` \\lipsum[1-15] # More random content \\lipsum[16-30] 在上面的 cat 代码块中的 LaTeX 代码中，我们定义了 PDF 文档的页眉和页脚。如果我们还想在页脚中显示作者姓名，我们可以用选项engine.opts = list(file = 'preamble.tex', append = TRUE) 和 code = sprintf('\\\\fancyfoot[LO,RE]{%s}', rmarkdown::metadata$author)将作者信息附加到另一个 cat 代码块中的 preamble.tex 中。要理解这是如何工作的，请回忆一下我们在本节前面提到的：engine.opts 被传递给 base::cat()。(因此 append = TRUE 被传递给 cat())，你可以通过阅读16.2节来理解chunk选项代码。 12.6.3 将 YAML 数据写入文件并显示它 默认情况下，cat 代码块的内容不会显示在输出文档中。如果还想在写出它之后显示它，则将块选项 class.source 设置为语言名称。语言名称用于语法高亮显示。在下面的例子中，我们指定为 yaml 语言： ```{cat, engine.opts=list(file=&#39;demo.yml&#39;), class.source=&#39;yaml&#39;} a: aa: &quot;something&quot; bb: 1 b: aa: &quot;something else&quot; bb: 2 ``` 其输出显示在下面，并且还生成了一个文件 demo.yml。 a: aa: &quot;something&quot; bb: 1 b: aa: &quot;something else&quot; bb: 2 为了显示文件 demo.yml确实已经生成，我们可以尝试使用 yaml 包(Stephens et al. 2020)将其读入 R。 xfun::tree(yaml::read_yaml(&#39;demo.yml&#39;)) ## List of 2 ## |-a:List of 2 ## | |-aa: chr &quot;something&quot; ## | |-bb: int 1 ## |-b:List of 2 ## |-aa: chr &quot;something else&quot; ## |-bb: int 2 12.7 运行 SAS 代码 你可以使用 sas 引擎运行 SAS (https://www.sas.com) 代码。你需要确保 SAS 可执行文件在你的环境变量 PATH 中，或者(如果你不知道 PATH 是什么意思)通过 chunk 选项 engine.path 来提供 SAS 可执行文件的完整路径，例如：engine.path = \"C:\\\\Program Files\\\\SASHome\\\\x86\\\\SASFoundation\\\\9.3\\\\sas.exe\"。下面是一个输出 “Hello World” 的示例： ```{sas} data _null_; put &#39;Hello, world!&#39;; run; ``` 12.8 运行 Stata 代码 如果你安装了Stata，你可以通过 stata 引擎 Stata (https://www.stata.com) 来运行 Stata (https://www.stata.com) 代码。除非可以通过环境变量 PATH 找到 stata 可执行文件，否则你需要通过 chunk 选项 engine.path 指定到可执行文件的完整路径，例如：engine.path = \"C:/Program Files (x86)/Stata15/StataSE-64.exe\"。下面给出一个例子： ```{stata} sysuse auto summarize ``` 在 knitr 中的 stata 引擎是相当有限的。Doug Hemken已经通过Statamarkdown包 中对其进行了实质性的扩展，该包可以通过Github中获得，地址为： https://github.com/Hemken/Statamarkdown。通过在线搜索 “Stata R Markdown”，你可以找到关于这个包的教程。 12.9 用渐近线 Asymptote 创建图形 渐近线 Asymptote (https://asymptote.sourceforge.io) 是矢量图形的强大语言。如果您你已经安装了 Asymptote，你可以使用 asy 引擎在 R Markdown 中编写并运行 Asymptote 代码(有关安装的说明，请参阅其网站)。下面是从仓库 https://github.com/vectorgraphics/asymptote 中复制的示例，其输出如图 ?? 所示： import graph3; import grid3; import palette; settings.prc = false; currentprojection=orthographic(0.8,1,2); size(500,400,IgnoreAspect); real f(pair z) {return cos(2*pi*z.x)*sin(2*pi*z.y);} surface s=surface(f,(-1/2,-1/2),(1/2,1/2),50,Spline); surface S=planeproject(unitsquare3)*s; S.colors(palette(s.map(zpart),Rainbow())); draw(S,nolight); draw(s,lightgray+opacity(0.7)); grid3(XYZgrid); 注意，对于PDF输出，可能需要一些额外的 LaTeX 包，否则可能会出现如下错误： ! LaTeX Error: File `ocgbase.sty&#39; not found. 如果出现这种错误，请参见 1.3 章节了解如何安装丢失的 LaTeX 包。 在上面的 asy 块中，我们使用了 settings.prc = false 的设置。如果没有此设置，当输出格式为 PDF 时，渐近线将生成交互式 3D 图形。但是，交互图形只能在 Acrobat Reader 中查看。如果使用 Acrobat Reader，则可以与图形交互。例如，你可以用鼠标旋转图??中的 3D 表面。 12.9.1 在R中生成数据并通过 Asymptote 读取 现在我们展示一个示例，其中我们首先将在 R 中生成的数据保存到 CSV 文件中(下面是一个 R 代码块)： x = seq(0, 5, l = 100) y = sin(x) writeLines(paste(x, y, sep = &#39;,&#39;), &#39;sine.csv&#39;) 然后通过 Asymptote 读取，并根据图 ?? 所示的数据绘制图表(下面是一个 asy 的代码块)： import graph; size(400,300,IgnoreAspect); settings.prc = false; // import data from csv file file in=input(&quot;sine.csv&quot;).line().csv(); real[][] a=in.dimension(0,0); a=transpose(a); // generate a path path rpath = graph(a[0],a[1]); path lpath = (1,0)--(5,1); // find intersection pair pA=intersectionpoint(rpath,lpath); // draw all draw(rpath,red); draw(lpath,dashed + blue); dot(&quot;$\\delta$&quot;,pA,NE); xaxis(&quot;$x$&quot;,BottomTop,LeftTicks); yaxis(&quot;$y$&quot;,LeftRight,RightTicks); 12.10 使用 Sass/SCSS 构建 HTML 页面风格 Sass (https://sass-lang.com) 是一种 CSS 扩展语言，它允许你以比普通 CSS 更灵活的方式创建 CSS 规则。如果你有兴趣学习它，请查看它的官方文档。 sass (Cheng et al. 2021) (Cheng et al. 2020)包可以用来编译 Sass 到 CSS。基于 sass 包，knitr 包含两个语言引擎： sass和 scss (分别对应于Sass和SCSS语法)，将代码块编译为CSS。下面是一个 scss 代码块，头部块为```{scss}： $font-stack: &quot;Comic Sans MS&quot;, cursive, sans-serif; $primary-color: #00FF00; .book.font-family-1 { font: 100% $font-stack; color: $primary-color; } .book.font-family-1{font:100% \"Comic Sans MS\",cursive,sans-serif;color:lime} 你还可以使用 sass 引擎，并且 Sass 语法与 SCSS 语法略有不同，例如: ```{sass} $font-stack: &quot;Comic Sans MS&quot;, cursive, sans-serif $primary-color: #00FF00 .book.font-family-1 font: 100% $font-stack color: $primary-color ``` 如果你正在阅读本节的HTML版本，你会注意到该页的字体已被更改为 Comic Sans，这可能会令人吃惊，但请不要恐慌，你并没有中风)。 sass/scss 代码块是通过sass::sass()函数编译而成的。目前，你可以通过chunk选项 engine.opts 定制 CSS 代码的输出样式，例如：engine.opts = list(style = \"expanded\")。默认的样式是 “compressed”。如果你不确定这意味着什么，请参阅帮助页面 ?sass::sass_options并寻找 output_style 对应的参数。 实际上，你应该改用内置的python引擎，该引擎基于 reticulate 软件包，并且更好地支持Python代码块(见15.2节）↩︎ "],["Dashboards.html", "第 13 章 Dashboards 13.1 入门 13.2 排版 13.3 组件 13.4 Shiny", " 第 13 章 Dashboards 在本章中，我们将介绍基于 flexdashboard 包 (Iannone, Allaire, and Borges 2020) 的仪表盘设计。 仪表盘在业务风格的报告中特别常见。它们可以用来展示报告的概要和关键内容。仪表盘的布局通常是基于网格搭建的，各个组件排列在各种大小的“盒子”中。 使用 flexdashboard 包，你可以 使用 R Markdown 将一组相关数据可视化作为指示盘进行发布。 嵌入各种各样的组件，包括 HTML 小部件、R 图形、表格数据和文本注释等内容。 可以指定按行或列进行布局(各组件会自动调整大小以填满浏览器，并且在移动设备上也十分适配)。 可以创建故事板来呈现可视化图形和相关注释。 使用 Shiny 驱动动态可视化图表。 13.1 入门 首先，安装flexdashboard包： install.packages(&quot;flexdashboard&quot;) 其次，通过点击 File -&gt; New File -&gt; R Markdown 对话框在 RStudio 中创建文档，并选择 “Flex Dashboard” 模板。这是我们就已经创建了一个新的dashboard文件了。操作界面如图13.1所示： 图 13.1: 创建新的dashboard文件 注：如果你并没有使用 RStudio进行操作，那么你也可以从 R 控制台创建一个新的 flexdashboard 的 R Markdown 文件，具体操作如下： rmarkdown::draft( &quot;dashboard.Rmd&quot;, template = &quot;flex_dashboard&quot;, package = &quot;flexdashboard&quot; ) 本章只介绍一些基本特性和用法。如果你想更进一步了解 flexdashboard，可以查看它的完整文档： https://rmarkdown.rstudio.com/flexdashboard/ 。 仪表盘有许多与 HTML 文档相同的特性(Section 5)，比如图形选项 (Section ??)，外观和风格5.2)，MathJax 公式 ??)，头部和正文前后内容 (Section ??) 和 Pandoc 参数(Section ??)，等等。建议大家有时间的话，把前面提到的几节内容也看一下。除此之外，我们也建议你浏览 R 帮助页面 ?flexdashboard::flex_dashboard 来了解更多 flexdashboard 选项和其特性。 当然Rstudio官网也给出了该包的视频介绍以及一些案例，你可以通过学习案例对应的代码实现快速入门。 13.2 排版 关于仪表盘布局的总体规则是： 一级标题：生成页面； 二级标题：生成列（或行）； 三级标题：生成框（包含一个或多个仪表盘组件）。 下面给出一个简单的例子： --- title: &quot;Get Started&quot; output: flexdashboard::flex_dashboard --- ```{r setup, include=FALSE} library(flexdashboard) ``` Column 1 -------------------------------------------------- ### Chart A ```{r} ``` Column 2 -------------------------------------------------- ### Chart B ```{r} ``` ### Chart C ```{r} ``` 请注意，第一行文本（Coluumn 1）下的一系列破折号是第二级标题的另一种 Markdown 语法形式，即： Column 1 -------------------------------------------------- 等同于 ## Column 1 我们使用了一系列的破折号，只是为了让第二节在源文档中更为显眼罢了。 默认情况下，二级标题在仪表板上生成列，三级标题在列中垂直堆叠。所以在默认情况下，你不必在仪表盘上设置列，因为它默认会一列一列的垂直堆放显示。 注：二级标题的内容将不会显示在输出中。二级标题仅用于布局（例如，例子中的Column 1不会现实在输出中），因此标题的实际内容一点都不重要。相比之下，一级标题和三级标题更加重要。 图 13.2 显示了上述示例的结果，一共是两列，第一列为 “Chart A”，第二列为 “Chart B” 和 “Chart C”。 注：在这个例子中，我们没有在代码块中加入任何 R 代码，所以所有的框都是空的。当然在实际使用中，你可以编写任意的 R 代码来生成 R 图、HTML 小部件或 13.3 节中介绍的各种其他组件，并将其加入到这些“盒子”中。 图 13.2: 简单仪表盘布局示例 13.2.1 基于行的布局 通过修改 orientation 选项将默认以列导向的布局改为以行导向的布局，例如： output: flexdashboard::flex_dashboard: orientation: rows 这时二级结构中将会按照行进行排列，三级结构中会按照行中的列进行堆叠。我们将上述例子修改后，输出结果如图??所示： 图 13.3: 基于行布局的结果 13.2.2 节属性 二级结构头部还可以加入一些属性，例如：设置列宽度为350： A narrow column {data-width=350} -------------------------------- 在基于行布局的情况下，可以为行设置 data-height 属性。而基于列布局的情况下，可以使用 {.tabset} 使得三级结构以制表符的形式排列，例如： Two tabs {.tabset} ------------------ ### Tab A ### Tab B 所得结果如图??所示： 图 13.4: 以制表符的形式排列所得到的结果 13.2.3 多页 如果rmd文档中有多个一级结构的内容时，这时仪表盘会将每个一节结构分别显示为单独页面。下面给出一个简单的例子： --- title: &quot;Multiple Pages&quot; output: flexdashboard::flex_dashboard --- Visualizations {data-icon=&quot;fa-signal&quot;} ===================================== ### Chart 1 ```{r} ``` ### Chart 2 ```{r} ``` Tables {data-icon=&quot;fa-table&quot;} ===================================== ### Table 1 ```{r} ``` ### Table 2 ```{r} ``` 图 13.5: 仪表盘上的多个页面情况 注：一系列等号是一级标题的另一种 Markdown 语法（也可以使用单个井号 #表示）。 从图 13.5 我们可以看到： 页面标题显示在仪表盘顶部的导航菜单中。一级结构单独构成一个页面。 本例中，我们还做了一个小拓展，通过 data-icon 属性将图标应用于页面标题中。当然，你可以从该网址 https://fontawesome.com 找到其他可用的图标。 13.2.4 故事板 除了基于列或行布局外，你还可以通过故事板（“storyboard”）进行布局，呈现一些可视化图形或其他说明。 下面给出一个简单的例子： --- title: &quot;Storyboard Commentary&quot; output: flexdashboard::flex_dashboard: storyboard: true --- ### A nice scatterplot here ```{r} plot(cars, pch = 20) grid() ``` --- Some commentary about Frame 1. ### A beautiful histogram on this board ```{r} hist(faithful$eruptions, col = &#39;gray&#39;, border = &#39;white&#39;, main = &#39;&#39;) ``` --- Some commentary about Frame 2. 图 13.6: 基于故事板布局的结果 如图 13.6 所示，你可以通过顶部的左右导航按钮来浏览所有故事板内容。 13.3 组件 仪表盘布局中可以包含各种各样的组件，包括： 基于 HTML 小部件的交互式 JavaScript 数据可视化图形。 R 图形，包括基础、栅栏和网格图形； 表格（可选选项包括：排序，过滤和分页等）； 数值框（展示重要数据）； 仪表盘； 文本注释； 导航栏（提供与仪表盘相关的更多链接）。 注：无论输出格式如何，前三个组件在大多数 R Markdown 文档中均可使用。 而后四个组件是仪表盘特有的，本节我们主要介绍后四个组件。 13.3.1 数值框 如果你希望在仪表盘中包含一个或多个数值，那么你可以使用 flexdashboard 包中的 valueBox() 函数来实现这个需求。下面给出一个简单的例子： --- title: &quot;Dashboard Value Boxes&quot; output: flexdashboard::flex_dashboard: orientation: rows --- ```{r setup, include=FALSE} library(flexdashboard) # these computing functions are only toy examples computeArticles = function(...) return(45) computeComments = function(...) return(126) computeSpam = function(...) return(15) ``` ### Articles per Day ```{r} articles = computeArticles() valueBox(articles, icon = &quot;fa-pencil&quot;) ``` ### Comments per Day ```{r} comments = computeComments() valueBox(comments, icon = &quot;fa-comments&quot;) ``` ### Spam per Day ```{r} spam = computeSpam() valueBox( spam, icon = &quot;fa-trash&quot;, color = ifelse(spam &gt; 10, &quot;warning&quot;, &quot;primary&quot;) ) ``` 图 13.7: 仪表盘上并排的三个值 图 13.7 展示了三个并排的仪表，每个仪表都显示了一个数值和标题。这里我们重点解释下第三个代码块（### Spam per Day）。这里的valueBox() 函数定义了一个值(spam)和一个图标(icon = \"fa-trash\")。并使用 color 设置参数框的颜色。内部使用了一个ifelse()语句，使得不同值表示不同的颜色。当然，可用的颜色还包括： \"info\", \"success\" 和 \"danger\"（默认值为： \"primary\"）。你也可以指定任何有效的 CSS 颜色（例如：\"#ffffff\"， \"rgb(100, 100, 100)\"等）。 13.3.2 仪表 仪表：在指定数值范围内显示仪表上的数值。例如，下面展示了三个仪表并排的结果（见图 13.8） --- title: &quot;Dashboard Gauges&quot; output: flexdashboard::flex_dashboard: orientation: rows --- ```{r setup, include=FALSE} library(flexdashboard) ``` ### Contact Rate ```{r} gauge(91, min = 0, max = 100, symbol = &#39;%&#39;, gaugeSectors( success = c(80, 100), warning = c(40, 79), danger = c(0, 39) )) ``` ### Average Rating ```{r} gauge(37.4, min = 0, max = 50, gaugeSectors( success = c(41, 50), warning = c(21, 40), danger = c(0, 20) )) ``` ### Cancellations ```{r} gauge(7, min = 0, max = 10, gaugeSectors( success = c(0, 2), warning = c(3, 6), danger = c(7, 10) )) ``` 图 13.8: 三个仪表并排放在仪表盘上 这个示例需要解释以下几点： 通过gauge() 函数设置一个仪表盘。其内部三个参数需要确定：value， min 和 max （可以是任何数值）。 可以指定一个可选的符号（symbol）和值一起显示(在示例中， “%” 用来表示百分比)。 可以使用 gaugeSectors() 函数指定一组自定义的颜色扇区，默认颜色为绿色。扇区选项（sectors）可以指定三个值的范围(success, warning 和 danger) 使得仪表盘的颜色根据它的值变化而变化。 13.3.3 文本注释 你可以通过以下方式在仪表盘中包含额外的叙述说明： 在页面顶部加入相应文本内容。 定义不包含图表，而是仅包含任意内容(文本、图像和方程等)的指示板。 如图13.9 所示，顶部包含了一些内容说明和右下角包含了一个只有内容的指示板： --- title: &quot;Text Annotations&quot; output: flexdashboard::flex_dashboard: orientation: rows --- Monthly deaths from bronchitis, emphysema and asthma in the UK, 1974–1979 (Source: P. J. Diggle, 1990, Time Series: A Biostatistical Introduction. Oxford, table A.3) ```{r setup, include=FALSE} library(dygraphs) ``` Row {data-height=600} ------------------------------------- ### All Lung Deaths ```{r} dygraph(ldeaths) ``` Row {data-height=400} ------------------------------------- ### Male Deaths ```{r} dygraph(mdeaths) ``` &gt; Monthly deaths from lung disease in the UK, 1974–1979 ### About dygraphs This example makes use of the dygraphs R package. The dygraphs package provides rich facilities for charting time-series data in R. You can use dygraphs at the R console, within R Markdown documents, and within Shiny applications. 图 13.9: 仪表盘上的文本注释 注：仪表盘中的每个组件都可以包括标题和注释部分。三级结构 (###) 后面的文本为标题；&gt; 开头的文本是注释。 13.3.4 导航栏 默认情况下，仪表盘的导航栏包括：标题（title）、作者（author）和日期（date）。当仪表盘有多个页面时(第??节)，导航条左侧还包含指向各个页面的链接。当然，你也在可以仪表盘上添加社交链接。 除此之外，使用 navbar 选项可以在导航栏中添加自定义链接。例如，在导航栏中添加 “About” 链接： --- title: &quot;Navigation Bar&quot; output: flexdashboard::flex_dashboard: navbar: - { title: &quot;About&quot;, href: &quot;https://example.com/about&quot; } --- 这时得到的界面如图13.10下所示： 图 13.10: 导航栏中添加自定义链接 注：导航栏必须包括标题或图标(或两者都包含)。你还可以使用 href 作为导航目标。如果想调整文本对齐方式，可以使用 align 参数 (默认情况下为右对齐)。 除此之外，你可以通过 social 选项添加社交链接。例如，下面的仪表盘包括了 Twitter 和 Facebook 链接，以及一个包含更多服务的下拉菜单： --- title: &quot;Social Links&quot; output: flexdashboard::flex_dashboard: social: [ &quot;twitter&quot;, &quot;facebook&quot;, &quot;menu&quot; ] --- 这时得到的界面如图13.11下所示： 图 13.11: 导航栏中添加社交选项 社交链接选项还包括：\"facebook\", \"twitter\", \"google-plus\", \"linkedin\" 和 \"pinterest\"。 13.4 Shiny 在仪表盘中添加 Shiny，可以利用viewers更改参数，并显示实时结果。或者当仪表盘的数据发生变化时，让仪表盘进行实时更新(请参阅 shiny 包中的 reactiveFileReader() 和 reactivePoll() 函数)。这是通过将 runtime: shiny 添加到标准仪表盘文档来实现的，然后添加一个或多个输入控件或响应式表达式来动态驱动仪表板内组件的外观。 在 flexdashboard 中使用 Shiny 可以将一个静态的 R Markdown 报告变成一个交互式文档。需要注意的是，交互式文档需要部署到 Shiny 的服务器上，以便广泛共享(而静态 R Markdown 文档是可以附加到电子邮件或从任何标准 web 服务器提供的独立 web 页面)。 注意， shinydashboard 包提供了用 Shiny 创建仪表板的另一种方法。 13.4.1 入门指南 在仪表盘中添加 Shiny 组件的步骤如下： 在文档顶部 YAML 元数据中添加 runtime: shiny。 在仪表盘第一列添加 {.sidebar} 属性，使其成为 Shiny 控件输入的控制台（注：这一步不是必须的，但这是基于 Shiny 仪表盘的经典布局）。 根据需求，添加 Shiny 的输入和输出。 当代码中包含绘图函数时（例如： hist()），得将它们封装在 renderPlot() 中。这有利于界面在布局更改时，自动调整尺寸大小。 13.4.2 Shiny 仪表盘的一个示例 图 13.12 给出了 Shiny 仪表盘的一个示例： --- title: &quot;Old Faithful Eruptions&quot; output: flexdashboard::flex_dashboard runtime: shiny --- ```{r global, include=FALSE} # load data in &#39;global&#39; chunk so it can be shared # by all users of the dashboard library(datasets) data(faithful) ``` Column {.sidebar} -------------------------------------------------- Waiting time between eruptions and the duration of the eruption for the Old Faithful geyser in Yellowstone National Park, Wyoming, USA. ```{r} selectInput( &quot;n_breaks&quot;, label = &quot;Number of bins:&quot;, choices = c(10, 20, 35, 50), selected = 20 ) sliderInput( &quot;bw_adjust&quot;, label = &quot;Bandwidth adjustment:&quot;, min = 0.2, max = 2, value = 1, step = 0.2 ) ``` Column -------------------------------------------------- ### Geyser Eruption Duration ```{r} renderPlot({ erpt = faithful$eruptions hist( erpt, probability = TRUE, breaks = as.integer(input$n_breaks), xlab = &quot;Duration (minutes)&quot;, main = &quot;Geyser Eruption Duration&quot;, col = &#39;gray&#39;, border = &#39;white&#39; ) dens = density(erpt, adjust = input$bw_adjust) lines(dens, col = &quot;blue&quot;, lwd = 2) }) ``` 图 13.12: An interactive dashboard based on Shiny. 其中，仪表盘的第一列包含了 {.sidebar} 属性和两个 Shiny 的输入控件；第二列包含了绘制图表的 Shiny 代码。 注：文档顶部标记为 global 的 R 代码块在全局环境中都可以被调用。这将为用户带来更好的启动性能，强烈推荐大家使用。 13.4.3 输入栏 通过添加 {.sidebar} 属性设置一个默认布局为左对齐，250像素宽度的左侧边栏。 在搭建多个页面的仪表盘时，如果你想创建一个应用于所有页面的工具条。这时，你可以使用一级结构来定义侧边栏。 13.4.4 拓展 下面给出一些学习 Shiny 和创建交互式文档的资源： Shiny 官方网站( http://shiny.rstudio.com) ：包含大量的文章、教程和示例。 Shiny 网站上的文章“Introduction to Interactive Documents”，这是一个很好的入门指南。 关于部署交互式文档，你可以使用 Shiny Server 或 RStudio Connect：https://www.rstudio.com/products/shiny/shiny-server/。 "],["shiny-started.html", "第 14 章 Shiny 14.1 入门指南 14.2 部署 14.3 嵌入 Shiny 应用程序 14.4 Shiny 小部件 14.5 多页 14.6 延迟渲染 14.7 渲染函数的输出参数", " 第 14 章 Shiny Shiny 包（Chang等，2021年）构建了由 R 驱动的交互式 Web 应用程序。要从 R Markdown 文档中调用 Shiny 代码，在 YAML 元数据添加 runtime: shiny 即可。Shiny 是用于构建基于 R 的 Web 应用程序的功能非常强大的框架。本书不全面介绍 Shiny（这是一个太大的话题），超出了本书的范围。 我们建议不熟悉 Shiny 的读者在阅读本章之前，先从 https://shiny.rstudio.com 网站了解有关它的更多信息。 与创建静态报告的传统工作流不同，你可以创建允许读者更改分析基础参数的文档，并在 Shiny 的 R Markdown 文档中立即看到结果。 一张图片胜过千言万语，当你与它互动时，一份 Shiny 文档可能会向你展示上千张图片。读者不再被报告中固定的分析和结论所束缚。他们可能会自己探索其他可能性，可能会有新的发现或得出不同的结论。 14.1 入门指南 你可以通过在 YAML 元数据中加入 runtime: shiny，这样就可以把任何面向 html 的 R Markdown 文档变成 Shiny 文档了，例如： --- title: &quot;Shiny Document&quot; output: html_document runtime: shiny --- 注意，R Markdown 文档的输出格式必须是 HTML 格式。也就是说，文档最后生成的是一个 web 页面（*.html 文件）。 注意： 非 html 格式，如 pdf_document 和 word_document 将不能与 Shiny 同时运行。另外，一些演示格式也是 HTML 格式，比如ioslides_presentation 和 slidy_presentation。 你也通过RStudio构建一个新的Shiny文档。步骤如下：File -&gt; new File -&gt; R Markdown 并选择Shiny，具体见图14.1。 图 14.1: Create a new Shiny document in RStudio. 要在 RStudio 中运行 Shiny 文档，你需要单击编辑器工具栏上的 “Run Document” 按钮(当 RStudio 检测到这是 Shiny 文档时，它会自动将 Knit 按钮替换为 run document)。如果你没使用 RStudio，或者想在 R 控制台运行文档进行故障排除，你可以调用函数 rmarkdown::run() 并将文件名传递给它。 你可以在文档中嵌入 Shiny 的输入和输出。输入发生变化时，输出将自动更新。在下面的示例中，我们创建一个名称为 rows 的数字输入( numericInput )，然后在生成输出时通过 input$rows 引用其值： ```{r, echo=FALSE} numericInput(&quot;rows&quot;, &quot;How many cars?&quot;, 5) renderTable({ head(cars, input$rows) }) ``` 图 14.2: Increase the number of rows in the table in a Shiny document. 在上面的示例中，输出代码包装在对 renderTable() 的调用中。 Shiny 中还有许多其他渲染功能可用于绘图、打印的 R 输出等。 本示例使用 renderPlot() 创建动态绘图输出： ```{r, echo=FALSE} sliderInput(&quot;bins&quot;, &quot;Number of bins:&quot;, 30, min = 1, max = 50) renderPlot({ x = faithful[, 2] # Old Faithful Geyser data bins = seq(min(x), max(x), length.out = input$bins + 1) # draw the histogram with the specified number of bins hist(x, breaks = bins, col = &#39;darkgray&#39;, border = &#39;white&#39;) }) ``` 图 14.3: Change the number of bins of a histogram in a Shiny document. 14.2 部署 Shiny 文档必须由后台实时 R 会话支持。当你在本地运行一个 Shiny 文档时，它会使用你的本地 R 会话。通常只有你才能看到文档并与之交互。如果你希望与没有安装 R 的用户共享文档，或者不希望在本地运行文档，则必须将文档部署到服务器上，并共享文档的 URL。那么其他人只需要一个 web 浏览器就可以访问你的文档。 有两种方法可以部署 Shiny 文档。你可以使用 RStudio 提供的托管服务，也可以设置自己的服务器。 第一种方法从技术上来说比较容易，但是有时你可能不被允许使用外部托管服务，因此莫必须在自己的服务器上安装必需的软件（Shiny Server 或 RStudio Connect） 才能部署 Shiny 文档。 14.2.1 ShinyApps.io 你可以把 Shiny 文档发布到 ShinyApps (https://shinyapps.io) 进行托管服务。 要做到这一点，就应该确保你有： 在 ShinyApps 上注册一个账号(使用注册表单申请一个账号)。 最新版本的 rsconnect 包。你可以按照如下方式安装它 install.packages(&quot;rsconnect&quot;) 然后，从包含文档的工作目录中执行： rsconnect::deployApp() 如果你使用的是 RStudio，那么在运行一个 Shiny 文档时，还可以使用窗口右上角的 Publish 按钮(参见图 14.4)。 图 14.4: Deploy a Shiny document to ShinyApps.io. 如果目录中有一个名为 index.Rmd 的文件，它将用作该目录的默认文档，否则，如果要访问此 Rmd 文档，则应在 URL 中指定 Rmd 文件的显式路径。 例如，部署到 ShinyApps 的 index.Rmd 的 URL 可以采用以下形式 https://example.shinyapps.io/appName/，并且 test.Rmd 的 URL 可以采用以下形式 https://example.shinyapps.io/appName/test.Rmd。 14.2.2 Shiny Server / RStudio Connect Both Shiny Server (https://www.rstudio.com/products/shiny/shiny-server/) and RStudio Connect (https://www.rstudio.com/products/connect/) can be used to publish Shiny documents. They require knowledge about Linux. Installing and configuring them should normally be a task for your system administrator if you are not familiar with Linux or do not have the privilege. Shiny Server (https://www.rstudio.com/products/shiny/shiny-server/) 和 RStudio Connect (https://www.rstudio.com/products/connect/)都可以发布 Shiny 文档。 但是他们需要有关 Linux 的知识，如果你不熟悉 Linux 或没有特权，则安装和配置它们通常应该是系统管理员的任务。 14.3 嵌入 Shiny 应用程序 除了在 R Markdown 中嵌入单个 Shiny 的输入和输出外，还可以在文档中嵌入一个独立的 Shiny 应用程序。有两种方法可以做到这一点： 使用 shinyApp() 函数内联定义应用程序; 使用 shinyApp() 函数引用外部应用程序目录。 这两个函数在 shiny 包中都是可用的(不是 rmarkdown)，当在YAML元数据指定 runtime: shiny 时，它们会被自动加载。因此，你不必调用 library(shiny) 来加载 shiny。 14.3.1 内联应用程序 这个例子使用了内联定义： ```{r, echo=FALSE} shinyApp( ui = fluidPage( selectInput(&quot;region&quot;, &quot;Region:&quot;, choices = colnames(WorldPhones)), plotOutput(&quot;phonePlot&quot;) ), server = function(input, output) { output$phonePlot = renderPlot({ barplot(WorldPhones[,input$region]*1000, ylab = &quot;Number of Telephones&quot;, xlab = &quot;Year&quot;) }) }, options = list(height = 500) ) ``` 注意，使用 height 参数来确定嵌入式应用程序应该占用多少垂直空间。 14.3.2 外联应用程序 这个示例嵌入了一个定义在另一个目录中的 Shiny 应用程序。 ```{r, echo = FALSE} shinyAppDir( system.file(&quot;examples/06_tabsets&quot;, package=&quot;shiny&quot;), options = list(width = &quot;100%&quot;, height = 700) ) ``` 注意，在上面的所有代码块中，都使用了 echo = FALSE 的选项。这是为了防止块中的 R 代码与 Shiny 组件一起呈现到输出文档中。 14.4 Shiny 小部件 Shiny 小部件使你能够使用一个函数调用创建包含在 R Markdown 文档中的可重复使用的 Shiny 组件。还可以直接从控制台调用 Shiny 小部件(在创作过程中很有用)，并在 RStudio Viewer 窗格或外部 web 浏览器中显示它们的输出。 14.4.1 shinyApp() 函数 Shiny 窗口小部件的核心是使用 shinyApp() 函数创建的微型应用程序。 你无需像经典的 Shiny 应用程序那样创建 ui.R 和 server.R（或 app.R），而是将 UI 和服务器定义作为参数传递给 shinyApp() 函数。 我们在第 14.3.1 节中给出了一个示例。 最简单的 Shiny 小部件类型只是一个返回 shinyApp() 的 R 函数。 14.4.2 例子：k - means 聚类 rmdexamples 包 (https://github.com/rstudio/rmdexamples) 包括一个以上面所诉形式实现的Shiny小部件示例。 kmeans_cluster() 函数接受单个数据集（dataset）参数，并返回一个小部件来显示k-Means聚类的结果。你可以像这样在 R Markdown 文档中使用它： ```{r, echo = FALSE} library(rmdexamples) kmeans_cluster(iris) ``` 图 14.5 显示了在运行文档时小部件的样子。 图 14.5: A Shiny widget to apply k-Means clustering on a dataset. 下面是 kmeans_cluster() 函数的源代码： kmeans_cluster = function(dataset) { library(shiny) vars = names(dataset) shinyApp( ui = fluidPage( fluidRow(style = &quot;padding-bottom: 20px;&quot;, column(4, selectInput(&#39;xcol&#39;, &#39;X Variable&#39;, vars)), column(4, selectInput(&#39;ycol&#39;, &#39;Y Variable&#39;, vars, selected = vars[2])), column(4, numericInput(&#39;clusters&#39;, &#39;Cluster count&#39;, 3, min = 1, max = 9)) ), fluidRow( plotOutput(&#39;kmeans&#39;, height = &quot;400px&quot;) ) ), server = function(input, output, session) { # Combine the selected variables into a new data frame selectedData = reactive({ dataset[, c(input$xcol, input$ycol)] }) clusters = reactive({ kmeans(selectedData(), input$clusters) }) output$kmeans = renderPlot(height = 400, { res = clusters() par(mar = c(5.1, 4.1, 0, 1)) plot(selectedData(), col = res$cluster, pch = 20, cex = 3) points(res$centers, pch = 4, cex = 4, lwd = 4) }) }, options = list(height = 500) ) } 14.4.3 小部件的大小和布局 Shiny 小部件可以嵌入在不同的地方，包括标准的全宽页面、页面内的小列，甚至在 HTML5 幻灯片中。为了让小部件的大小和布局在所有这些上下文中都能很好地工作，我们建议小部件的总高度不大于500像素。这并不是一个硬性的规则，但是在HTML5幻灯片中，通常只能显示低于500px的内容，所以如果你想让你的小部件在演示中可用，这是一个很好的建议。 当然，你还可以在创建小部件的函数中添加一个显式的 height 参数（默认值为500）。 14.5 多页 你可以使用 Markdown 链接语法并指定文档的相对路径，链接到其他 Shiny 文档上，例如： [另一个Shiny文档]（another.Rmd）。如果在一个页面上单击指向另一个 Rmd 文档的链接，该 Rmd 文档将作为当前交互式闪亮文档启动。 目前，一次只能激活一个文档，因此尽管可以通过 R 脚本 global.R 进行一些原始的全局共享，但文档无法轻易共享状态（请参阅帮助页面 ?rmarkdown::run）。 默认情况下，只能链接到调用 rmarkdown::run() 的文件所在目录子树中的 R Markdown 文件(例如，你无法连接到 ../foo.Rmd)。 但是，你可以使用 rmarkdown::run() 的 dir 参数来定义根目录。 14.6 延迟渲染 一个 Shiny 文档通常在每次显示时都被呈现，并且在呈现完成之前不会显示给用户。因此，较大或包含昂贵计算的文档可能需要一些时间来加载。 如果你的文档包含不需要立即渲染的交互式 Shiny 组件，你可以在 rmarkdown::render_delayed() 函数中封装 Shiny 代码。这个函数保存它的参数，直到文档呈现完成并显示给用户，然后计算它，并在计算完成时将其注入输出文档。 下面我们将演示 render_delayed()是如何工作的。 render_delayed() 调用中包含的代码只有在加载了文档并显示给用户之后才会执行 ```{r, echo = FALSE} numericInput(&quot;rows&quot;, &quot;How many cars?&quot;, 5) rmarkdown::render_delayed({ renderTable({ head(cars, input$rows) }) }) ``` 14.7 渲染函数的输出参数 在一个典型的 Shiny 应用程序中，你可以使用 plotOutput() 和 verbatimTextOutput()等函数在 UI 中指定输出元素，并使用 renderPlot() 和 renderPrint() 等函数呈现其内容。 相比之下，在一个 Shiny 文档中，UI 元素通常是在调用 renderXXX() 函数时隐式和自动创建的。例如，你可能希望使用 renderPlot() 函数，而预先没有创建对应的 plotOutput()。在这种情况下，Shiny 将相应的输出对象与每个 renderXXX() 函数关联起来，让你可以在一个完整的 Shiny 应用程序之外使用 Shiny 代码。但是，在这个过程中可能会丢失一些功能。特别地，plotOutput() 可以接受一些可选参数来设置宽度和高度等内容，或者允许你单击或刷过绘图(并存储该信息)。 要将选项从 renderXXX() 传递到 xxxOutput()，可以使用 outputArgs 参数（如果特定的 renderXXX() 函数可用）。 例如：假设你要绘制一张宽度为200px，高度为100px的图形时。 你可以设定为如下形式： ```{r, echo = FALSE} renderPlot({ plot(yourData) }, outputArgs = list(width = &quot;200px&quot;, height = &quot;100px&quot;) ) ``` 无论你想设置多少个输出参数，outputArgs 总是设定为一个列表(默认是一个空列表，它不设置输出参数)。如果你试图传入一个不存在的参数，那么将得到以下的错误提示信息(在本例中，你试图设置一个名为 not_an_argument 的参数)： **Error**: Unused argument: in `outputArgs`, `not_an_argument` is not an valid argument for the output function 要查看运行中的 outputArgs，请运行下面的 R Markdown 文档或访问在线版 https://gallery.shinyapps.io/output-args/。文档是交互式的：在图像上刷新一下，看到 xmin, xmax, ymin 和 ymax 值的变化(正好印在图片下方)。 --- title: Setting output args via render functions runtime: shiny output: html_document --- This interactive Rmd document makes use of the `outputArgs` argument now available to all Shiny `render` functions. To give an example, this allows you to set arguments to `imageOutput` through `renderImage`. This means that you don&#39;t have to create a `ui` object just to be able to brush over an image. Note that this only applies to snippets of Shiny code during an interactive Rmd (and not to embedded full apps -- the ones you need to call `shinyApp` to run). ## Brushing over an image (and storing the data) ```{r setup, echo=FALSE} library(datasets) generateImage = function() { outfile = tempfile(fileext = &#39;.png&#39;) png(outfile) par(mar = c(0,0,0,0)) image(volcano, axes = FALSE) contour(volcano, add = TRUE) dev.off() list(src = outfile) } ``` ```{r image} renderImage({ generateImage() }, deleteFile = TRUE, outputArgs = list(brush = brushOpts(id = &quot;plot_brush&quot;), width = &quot;250&quot;, height = &quot;250px&quot;) ) ``` Here is some of the brushing info sent to the server: (brush over the image to change the data) ```{r brush info} renderText({ print(input$plot_brush) brush = input$plot_brush paste0(&quot;xmin: &quot;, brush$xmin, &quot;; &quot;, &quot;xmax: &quot;, brush$xmax, &quot;; &quot;, &quot;ymin: &quot;, brush$ymin, &quot;; &quot;, &quot;ymax: &quot;, brush$ymax) }) ``` --- ### Resizing a plot ```{r plot} renderPlot({ plot(cars) }, outputArgs = list(width = &quot;75%&quot;, height = &quot;250px&quot;) ) ``` 14.7.1 附加说明 我们要强调的是，你只能在一个 Shiny 的 R Markdown 文档中使用这个功能(也就是说，你必须在 YAML 元数据中设置 runtime: shiny )。但即使是这样，这也只适用于在 UI 中没有相应的显式输出元素的情况下呈现输出的 Shiny 代码片段。如果你在你的文档中嵌入一个完整的 Shiny 的应用程序，并尝试使用 outputArgs ，这时它将被忽略，并将以下警告打印到 R Markdown 控制台中(在这种情况下，你的 ui 函数将类似于 ui = plotOutput(\"plot\") )： Warning in `output$plot`(...) : Unused argument: outputArgs. The argument outputArgs is only meant to be used when embedding snippets of Shiny code in an R Markdown code chunk (using runtime: shiny). When running a full Shiny app, please set the output arguments directly in the corresponding output function of your UI code. 如果你尝试在其他任何上下文中使用 outputArgs，例如：在常用的（即非嵌入式）Shiny 应用程序内部使用 outputArgs，也会发生同样的情况。 基本原理解释如下：如果你已经在所有输出对象都明确指定的情况下指定了 ui 函数，则应在此处直接设置其参数，而不要采用这种绕行方式。 "],["custom-output.html", "第 15 章 自定义排版 15.1 有参数的 R Markdown 报告 15.2 文档模板 15.3 创建新的文档格式", " 第 15 章 自定义排版 本部分主要分为三个部分，第一部分介绍有参数的 R Markdown 报告， 第二部分介绍 R Markdown 模板并基于新模板创建文档， 第三部分介绍如何自定义一个 R Markdown 输出格式。 15.1 有参数的 R Markdown 报告 对于 R Markdown 文档来说，只需要一个命令就可以生成一份报告。不过在日常应用过程中， 一份报告可能会有不同的应用背景。比如日报、周报、月报、年报等这一类的周期性报告， 可能需要制定相应的时间，而中国、美国等这一类的区域性报告中，则需要经常变动相应的区域。 因此，这部分内容主要介绍使用参数来对 R Markdown 文档进行更多的定制， 这个技巧适合于周期性、区域性的自动化报告。这些变量可以被视为报告运行的参数， 这样的一份报告不妨称为“有参报告”。 15.1.1 声明参数 有参报告中的参数在 YAML 区块使用 params 来指定，每行一个参数。例如： --- title: &quot;文档标题&quot; output: html_document params: year: 2018 region: 欧洲 printcode: TRUE data: file.csv --- R Markdown 在编译过程中使用 yaml::yaml.load() 函数处理参数，可以识别 character， numeric，integer 和 logical 等不同类型的 R 标准类。此外，我们可以通过 !r 前缀 执行 R 语言表达式，获取参数的值。例如，在报告中使用当前日期可以这样操作： --- title: &quot;文档标题&quot; output: html_document params: date: !r Sys.Date() --- YAML 区块中的 R 语言表达式在编译时会先于文档中的其它 R 语言代码执行，因此需要在这里 使用 package::function 的写法来调用不同软件包中的函数（因为即便你在 R Markdown 文档 中已经使用 library(\"package\") 命令，该包在这一阶段仍然没有被载入）。例如： --- title: My Document output: html_document params: date: !r lubridate::today() --- 15.1.2 使用参数 YAML 区块中声明的参数在 R Markdown 中会被保存在一个名为 params 的只读列表中， 可以通过下面的方式来访问它们： params$year params$region 这些参数可以用来设置 knitr 的在编译时的行为。 例如通过赋值给 knitr 的区块参数 echo 来改变编译结果中是否显示源代码： import_example(file = &quot;examples/custom-report/change-echo-value.Rmd&quot;) --- params: printcode: false # or set it to true --- `r &#39;&#39;````{r, setup, include=FALSE} # 在这里将 echo 的值设为 false knitr::opts_chunk$set(echo = params$printcode) ``` 15.1.3 有参编译 除了像上面介绍的在 YAML 区块中声明参数，还有另外两种使用参数的方式： 通过向 rmarkdown::render() 函数的 params 参数赋值来设置编译的参数； 通过一个交互性的可视化界面来设置编译参数的值。 例如，下面的例子将起到与 前文 一样的效果。 rmarkdown::render(&quot;MyDocument.Rmd&quot;, params = list( year = 2017, region = &quot;亚洲&quot;, printcode = FALSE, file = &quot;file2.csv&quot; )) 这两种方法并不冲突，为了方便理解，你不妨将 YAML 区块中的设置视为默认配置。 当运行 rmarkdown::render() 进行有参编译时，如果在 params 下有新的设置， 那么将应用新的设置，否则使用原有的默认配置。 不过，rmarkdown::render() 执行有参编译时，也有其配置灵活的优势。 在下面的例子中，我们可以通过一个自定义函数来指定文档输出的位置。 render_report = function(region, year) { rmarkdown::render( &quot;MyDocument.Rmd&quot;, params = list( region = region, year = year ), output_file = paste0(&quot;Report-&quot;, region, &quot;-&quot;, year, &quot;.pdf&quot;) ) } 使用可视化界面来进行带参编译的方法有两种，一是直接在 RStudio 用户界面中的 Knit 按钮处的下拉菜单中选择 Knit with Parameters 命令，二是在 rmarkdown::render() 中将 params 的值设为 \"ask\"，即 rmarkdown::render(\"MyDocument.Rmd\", params=\"ask\")。 图 15.1 显示了通过可视化界面配置编译参数时的情形。 图 15.1: 使用图形界面配置编译参数 通过可视化界面可以直观的设置编译时所需的参数。而且，除了上图中所列出的样式， 我们还可以通过 YAML 区块来详细配置编译参数的可用数值范围及显示的模式，从而通过 滑块、复选框、文本框和下拉菜单来设置参数（图 15.2）。 图 15.2: 设置对话框的呈现形式 上图对话框的呈现形式通过下面的配置来实现的： import_example(&quot;examples/custom-report/custom-report-controls.Rmd&quot;) --- title: My Document output: html_document params: year: label: &quot;年份&quot; value: 2020 input: slider min: 2020 max: 2030 step: 1 sep: &quot;&quot; region: label: &quot;区域：&quot; value: 欧洲 input: select choices: [北美, 欧洲, 亚洲, 非洲] printcode: label: &quot;是否显示源代码&quot; value: TRUE data: label: &quot;数据源：&quot; value: results.csv input: file --- 在这里，给定了年份、区域等参数的范围，并分别通过滑块和下拉菜单时间实现了便捷赋值。 除了上面演示的例子，其它一些可用的控件可以参见表格 15.1 。 表 15.1: 有参编译用户界面中可用的 Shiny 控件 控件类型 对应的 Shiny 函数 checkbox checkboxInput numeric numericInput slider sliderInput date dateInput text textInput file fileInput radio radioButtons select selectInput password passwordInput 值得一提的是，该处用户界面的生成是基于 Shiny 技术的，其本质是一个动态网页。 因此，欲了解控件的详细配置（包括可用的参数名称）攻略，可以查看相应函数的文档。 例如 ?shiny::checkboxInput，?shiny::radioButtons 等等。 15.1.4 发布文档 有参数的 R Markdown 报告也可以发布到包括 RStudio Connect（https://www.rstudio.com/products/connect/）在内的网络服务器上。 发布后的 R Markdown 报告在运行时相当于一个动态网页，用户可以使用交互性空间设置 编译的参数，并得到相应的文档。 15.2 文档模板 前面已经多次提过，R Markdown 使用文档模板来定义输出的格式。不管是标准的 HTML 文档， 还是 PDF 文档，亦或是演示文稿等输出格式，都有相应的模板。不同的模板提供不同的功能和 样式。例如 HTML 文档通常使用 output: html_document 作为配置参数，PDF 文档通常使用 output: pdf_document 作为配置参数。 在 RStudio 中新建 R Markdown 文件时，有一项 \"From Template\" 的选项，这里列出了 当前可用的所有 R Markdown 文档模板。第 7.2 章我们讲述如何创建“写轮眼”幻灯片的部分， 我们曾经使用了这里的功能。 实际上，这些文档模板是拓展 R Markdown 功能的重要途径之一。通过创作自己的 R Markdown 模板，可以便利很多日常的工作任务。例如： 创建一个带有自己组织机构 LOGO、商标和视觉方案的模板，可在文档中充分体现组织特色； 在一个模板中指定 title，author，date 等参数的默认值，免得每一次都需要 重新设置； 指定输出文档的布局，并引入 YAML 区块中新的可用参数等。例如，你可以添加一个 department 参数来指定部门的名称； 新的 R Markdown 模板被创建后，可以非常便捷的在 RStudio 中使用（见图 15.3）。 图 15.3: 在 RStudio 中选择模板 RStudio 中可选的 R Markdown 模板会因为用户安装的软件包差异而有所不同。 在这一部分的内容中，我们将介绍如何创建一个新的模板。在此之外，你还可以通过参阅一些 软件包的源代码研究模板的创建。例如 rticles（https://github.com/rstudio/rticles） 软件包中定义了多个学术期刊的文档格式，而 rmarkdown::html_vignette 模板则是另一个 相对简单的实例。 15.2.1 模板的结构 R Markdown 模板仅可以通过创建一个新的 R 语言软件包来实现。本文不打算介绍软件包的 开发，而仅仅涉及模板的制作。对于没有经验的普通用户而言，不妨将这一途径视为 R Markdown 模板的分发策略。 简单来说，要创建一个新模板，首先需要创建一个 R 语言软件包项目。 这一步可以在 RStudio 中通过菜单 File -&gt; New Project 中选择 “R Package” 来完成。 R Markdown 模板位于软件包项目中的 inst/rmarkdown/templates 目录中。 这一位置是明确指定的，文件夹的名称和结构要确保正确。 假设我们要新建一个名为 my_template 的 R Markdown 模板，则需要在这一目录下再 新建一个子文件夹，并命名为 my_template。则该子文件夹下，至少需要以下两个文件： template.yaml skeleton/skeleton.Rmd 在 usethis 软件包中，提供了 use_rmarkdown_template() 函数来便捷化这一操作步骤 （参见?usethis::use_rmarkdown_template）。 其中，template.yaml 文件被用来指定在 RStudio 的 “From Template” 对话框中显示的 模板名称和描述。因此，这个 YAML 文件必须要指定 name 和 description 的值。 此外，通过设置可选参数 create_dir: true 在使用该模板时新建一个文件夹。如下所示： name: My Template description: This is my template 在 skeleton.Rmd 文件中，你可以创建一个 R Markdown 文档的默认框架，这里面指定了 应用该模板新建 R Markdown 文档后其中包括的默认内容。在下面的例子中，我们指定了 文档的标题、作者、输出格式和主要结构等。 import_example(&quot;examples/custom-report/template-skeleton.Rmd&quot;) --- title: &quot;未命名&quot; author: &quot;你的名字&quot; output: bookdown::html_document2: toc: true fig_caption: true template: flatly --- ## 前言 ## 分析和结果 ## 总结和讨论 15.2.2 模板支持文件 为了丰富 R Markdown 模板的内容、样式和功能，我们还需要在其中添加其它的支持文件。 这些文件都需要放置在 skeleton 文件夹中，当使用该模板创建的文档被编译时，相关的 支持文件会自动被拷贝到新文档生成的位置上，从而可以被新文档访问和使用。 如果我们想在模板中加入一个 LOGO 图片和 CSS 样式等内容，则可以在模板文件夹中 添加 logo.png 和 style.css 等文件。 template.yaml skeleton/skeleton.Rmd skeleton/logo.png skeleton/styles.css 为了应用新的样式，则需要在 skeleton.Rmd 中做下列修改： import_example(&quot;examples/custom-report/template-skeleton-extra.Rmd&quot;) --- title: &quot;未命名&quot; author: &quot;你的名字&quot; output: bookdown::html_document2: toc: true fig_caption: true css: style.css --- ![logo](logo.png) ## 前言 ## 分析和结果 ## 总结和讨论 15.2.3 设置 Pandoc 模板 前面的章节中已经提过，R Markdown 文档先由 knitr 编译为 Markdown，然后再通过 Pandoc 转换为其它各种不同的输出格式。在 Pandoc 的转换过程是通过对应的 Pandoc 模板 来实现的。Pandoc 模板的功能是将 YAML 区块的设置应用到文档转换的过程中，对诸如 HTML 文档的标题、作者等信息进行设置。 Pandoc 模板是一个标记文档，其中使用美元符号来标记变量和代码，实现文档内容的变化； 与此同时使用美元符号以外的部分来指定文档的静态内容。在下面的极简 HTML 文档模板中， 只有两个变量 $title$ 和 $body$，分别指定 HTML 文档的标题和页面内容。 &lt;html&gt; &lt;head&gt; &lt;title&gt;$title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $body$ &lt;/body&gt; &lt;/html&gt; 创建一个新的 Pandoc 文档模板后，可以在最终生成文档时使用新的变量。 比如，下面的例子将 前面 提到的 department 的内容写到 HTML 的 &lt;head&gt;&lt;/head&gt; 区域中去。这里使用 if 语句来检测是否存在 department 的赋值， 如果存在的话，则将其加入网页的 &lt;meta /&gt; 区域中。 &lt;html&gt; &lt;head&gt; &lt;title&gt;$title$&lt;/title&gt; $if(department)$&lt;meta name=&quot;department&quot; content=&quot;$department$&quot; /&gt;$endif$ &lt;/head&gt; &lt;body&gt; $body$ &lt;/body&gt; &lt;/html&gt; 值得一提的是，要应用上述 Pandoc 模板，还需要在 R Markdown 的 YAML 区块中进行配置。 output: html_document: template: template.html 除此之外，Pandoc 模板还有自己的一套语法来定义文档中的不同元素，包括条件判断、循环、 列表等的实现方法。其语法定义形式上比较简单，但是可读性较差。 在其 官方文档 中可查。 虽然这部分内容虽然通常不会用到，但是了解这一部分的内容有利于进一步理解 R Markdown 动态文档的工作原理。 15.2.4 分享模板 因为 R Markdown 的文档模板保存在 R 软件包中，所以模板的共享可以通过安装软件包来实现。 只要把 R Markdown 文档模板的软件包发布在 CRAN 或者 GitHub 网站，就可以通过安装软件包 的方式来使用该模板。 # 安装一个 CRAN 上的软件包 install.packages(&quot;packageName&quot;) # 安装一个 GitHub 上的软件包 remotes::install_github(&quot;github_username/packageName&quot;) 很多基于 R Markdown 软件包都携带了相应的 R Markdown 模板，包括 bookdown， xaringan，rticles 等。如果要深入了解这方面的内容，不妨去参考其源代码。 15.3 创建新的文档格式 作为实现 R Markdown 技术最重要的软件包之一，rmarkdown 软件包中已经包括了很多 文档和演示文稿的输出格式。这些文档格式的背后，本质上仍然是一些 R 语言的函数。当你 在 YAML 区块中指定输出格式的时候，实际上是在调用相应的函数并将函数的参数传递给它。 因此，我们也可以通过自定义一个新的函数来创建新的文档格式。新文档格式的函数通常需要 整合到新的 R Markdown 文档模板中去（参见第 ?? 章）。这是因为 文档模板是通过 R 语言软件包创建的，原本就可以加入新的函数。于是，通过 R 语言的软件包， 就实现了文档格式和模板的分发。这也是现有的 R Markdown 文档格式、模板的一贯做法。 15.3.1 从现有文档格式衍生新格式 创建新的文档格式最简单的办法就是基于现有的文档格式衍生出新的文档格式。rmarkdown 内嵌的文档格式都是高度可定制的，包含众多可用参数。只需要为这些参数赋值，就可以创建 出一个新的文档格式出来。 在下面的例子中，我们创建了一个新的文档格式函数 quarterly_report 以进行季度报告。 这个函数是基于 rmarkdown 的内嵌函数 html_document 工作的。 quarterly_report = function(toc = TRUE) { # 查找软件包的安装位置 pkg_resource = function(...) { system.file(..., package = &quot;mypackage&quot;) } # 在软件包的子目录中找到新文档格式依赖的文档模板 css = pkg_resource(&quot;reports/styles.css&quot;) header = pkg_resource(&quot;reports/quarterly/header.html&quot;) # 调用 html_document 函数并指定其参数 rmarkdown::html_document( toc = toc, fig_width = 6.5, fig_height = 4, theme = NULL, css = css, includes = rmarkdown::includes(before_body = header) ) } 这个新的输出格式实现了下列几项功能： 提供了一个参数 toc 来决定是否显示文档目录（参数最后被传递给了 html_document）； 指定了图片默认的长度和高度（这可以避免文档中的图片出现大小参差不齐的现象）； 指定了一个新的 CSS 样式表，同时也禁用了默认的 Bootstrap 主题样式表； 在每一份文档中都添加了一个标准的头文件。 值得一提的是，第 3 项和第 4 项功能依赖于软件包提供的外部文件。也就是说， 在 quarterly_report 函数中，分别获取了 \"mypackage\" 的软件包中携带的 CSS 文件和 一个 HTML 文档，然后分别将 CSS 定义传递给了 html_document 函数的 css 和 includes 参数。在这里，后者使用了一个 rmarkdown::includes() 函数，从而将这个 HTML 文档（片段） 作为文档 before_body 的内容嵌入到使用该格式的文档中去。 15.3.2 完全的自定义输出格式 在基于现有格式衍生新输出格式之外，我们也可以从底层出发创建出一个完全的新格式。 为此我们需要了解文档格式的底层工作原理，简单来说 R Markdown 的输出格式 由下列几个部分构成： 一系列的参数来确保 knitr 将 Rmd 文件正确的编译为 Markdown 格式的文档； 另外的一些参数来指导 Pandoc 将 Markdown 文档转换为其它输出格式（如 HTML）； 其它的一些标记或过滤器（通常用于处理输出格式的支持文件）。 你可以使用 rmarkdown 软件包中的函数 output_format() 来创建一个新的输出格式。 下面是一个例子： simple_html_format = function() { # 这里使用了完整的引用方式来使用 output_format、knitr_options 和 # pandoc_options 等 3 个函数。 rmarkdown::output_format( knitr = rmarkdown::knitr_options(opts_chunk = list(dev = &#39;png&#39;)), pandoc = rmarkdown::pandoc_options(to = &quot;html&quot;), clean_supporting = FALSE ) } 在这个函数中，knitr 和 Pandoc 的参数分别由两个参数指定，其内容可以相当的复杂 （参见 ?rmarkdown::knitr_options 和 ?rmarkdown::pandoc_options 了解更多）。 而 clean_supporting 则控制是否清理文档编译过程中使用的临时文件。 output_format() 函数中还有一个 base_format 参数用来指定一个原有的输出格式， 并在此基础上进行配置（相当于衍生格式）。 如果你有其它的一些支持文件无法通过 includes 参数指定，那么还需要使用 output_format() 中的其它参数来帮助你处理这些文件（例如，使用 intermediates_generator 来讲它们拷贝 到文档的输出目录中去）。 学习创建一个新的文档输出格式最好的方法可能是阅读原有格式的源代码。从 rmarkdown 的 html_document 和 pdf_document 开始是个不错的主意，其源代码的位置在 https://github.com/rstudio/rmarkdown/tree/master/R。如果你的新格式需要用到 Pandoc 模板，则请参见 15.2.3 及 Pandoc 的使用手册。 15.3.3 使用新的文档输出格式 新的文档格式在创建完成后，需要安装到你的本地环境中去（参见 15.2.4）。 这样新的输出格式便可以通过 YAML 区块来应用。加入我们的 quarterly_report 位于一个 名为 mypackage 的软件包中且该软件包已经安装成功，那么： --- title: &quot;文档标题&quot; output: mypackage::quarterly_report: toc: true --- 这里面就设置了新的输出格式，并且将 toc 参数传递给了 quarterly_report() 函数。 "],["references.html", "参考文献", " 参考文献 Cheng, Joe, Timothy Mastny, Richard Iannone, Barret Schloerke, and Carson Sievert. 2021. Sass: Syntactically Awesome Style Sheets (Sass). https://github.com/rstudio/sass. Dahl, David B., David Scott, Charles Roosen, Arni Magnusson, and Jonathan Swinton. 2019. Xtable: Export Tables to LaTeX or HTML. http://xtable.r-forge.r-project.org/. Iannone, Richard, JJ Allaire, and Barbara Borges. 2020. Flexdashboard: R Markdown Format for Flexible Dashboards. http://rmarkdown.rstudio.com/flexdashboard. Ooms, Jeroen. 2021. Magick: Advanced Graphics and Image-Processing in r. https://CRAN.R-project.org/package=magick. Sharpsteen, Charlie, and Cameron Bracken. 2020. tikzDevice: R Graphics Output in LaTeX Format. https://github.com/daqana/tikzDevice. Stephens, Jeremy, Kirill Simonov, Yihui Xie, Zhuoer Dong, Hadley Wickham, Jeffrey Horner, reikoch, Will Beasley, Brendan O’Connor, and Gregory R. Warnes. 2020. Yaml: Methods to Convert r Data to YAML and Back. https://github.com/viking/r-yaml/. Strayer, Nick, Javier Luraschi, and JJ Allaire. 2020. R2d3: Interface to D3 Visualizations. https://github.com/rstudio/r2d3. Ushey, Kevin, JJ Allaire, and Yuan Tang. 2020. Reticulate: Interface to Python. https://github.com/rstudio/reticulate. Xie, Yihui. 2020. Bookdown: Authoring Books and Technical Documents with r Markdown. https://github.com/rstudio/bookdown. ———. 2021a. formatR: Format r Code Automatically. https://github.com/yihui/formatR. ———. 2021b. Xaringan: Presentation Ninja. https://github.com/yihui/xaringan. ———. 2021c. Xfun: Supporting Functions for Packages Maintained by Yihui Xie. https://github.com/yihui/xfun. Zhu, Hao. 2020. kableExtra: Construct Complex Table with Kable and Pipe Syntax. https://CRAN.R-project.org/package=kableExtra. "]]
